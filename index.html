<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beth's Book Club</title>
    <!-- Tailwind CSS CDN for sleek styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs (Modular versions) -->
    <script type="module">
        // Basic console log to confirm script is loading
        console.log("Beth's Book Club script is loading...");

        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getAuth } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js"; // Keep getAuth for internal Firebase use if needed, but not for login
        import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-analytics.js"; // Added analytics import

        // Global Firebase variables (assigned after initialization)
        window.firebaseApp = null;
        window.db = null;
        window.auth = null; // Still initialized, but not used for user login in this PIN-based setup
        window.adminUserId = null; // This will store the fixed user ID for Beth
        window.analytics = null; // Added analytics global

        // Global data stores (will be updated by Firestore listeners)
        window.recommendedBooks = [];
        window.bookShelfBooks = [];
        window.flaggedBooks = [];
        window.bethDeletedBooks = [];
        window.adminAlerts = [];
        window.adminPendingRecommendations = [];
        window.adminApprovedBooks = [];

        // Fixed PINs for login
        const BETH_PIN = '7288'; // Corrected Beth's PIN
        const ADMIN_PIN = '2384'; // Admin PIN
        // Fixed user ID for Beth's data in Firestore
        const BETH_FIREBASE_USER_ID = 'beth_unique_book_club_id_7288';

        // Keys for local storage migration flags (re-introduced for migration logic)
        const RECOMMENDED_BOOKS_KEY = 'recommendedBooks';
        const BOOK_SHELF_BOOKS_KEY = 'bookShelfBooks';
        const FLAGGED_BOOKS_KEY = 'flaggedBooks';
        const BETH_DELETED_BOOKS_KEY = 'bethDeletedBooks';
        const ADMIN_ALERTS_KEY = 'adminAlerts';
        const ADMIN_PENDING_RECS_KEY = 'adminPendingRecommendations';
        const ADMIN_APPROVED_BOOKS_KEY = 'adminApprovedBooks';
        const BETH_NEGATIVE_FEEDBACK_KEY = 'bethNegativeFeedback';

        const MIGRATED_RECOMMENDED_BOOKS_FLAG = 'migrated_recommended_books_v1';
        const MIGRATED_BOOKSHELF_BOOKS_FLAG = 'migrated_bookshelf_books_v1';
        const MIGRATED_FLAGGED_BOOKS_FLAG = 'migrated_flagged_books_v1';
        const MIGRATED_BETH_DELETED_BOOKS_FLAG = 'migrated_beth_deleted_books_v1';
        const MIGRATED_ADMIN_ALERTS_FLAG = 'migrated_admin_alerts_v1';
        const MIGRATED_ADMIN_PENDING_RECS_FLAG = 'migrated_admin_pending_recs_v1';
        const MIGRATED_ADMIN_APPROVED_BOOKS_FLAG = 'migrated_admin_approved_books_v1';
        const MIGRATED_BETH_NEGATIVE_FEEDBACK_FLAG = 'migrated_beth_negative_feedback_v1';
        const MIGRATED_INITIAL_BOOKSHELF_FLAG = 'migrated_initial_bookshelf_v1';


        // --- Firestore Collection Paths ---
        // Helper function to get collection path based on whether it's public or user-specific
        function getCollectionPath(collectionName, userId = null) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // If userId is explicitly provided, use it. Otherwise, default to the fixed Beth's ID.
            const effectiveUserId = userId || window.adminUserId; // Use window.adminUserId as fallback
            if (effectiveUserId) {
                return `artifacts/${appId}/users/${effectiveUserId}/${collectionName}`;
            } else {
                return `artifacts/${appId}/public/data/${collectionName}`;
            }
        }

        // --- Local Storage Migration Functions (for one-time migration) ---

        /**
         * Migrates data from localStorage to Firestore for a given collection.
         * @param {string} localStorageKey - The key for the data in localStorage.
         * @param {string} migrationFlagKey - The localStorage key for the migration flag.
         * @param {string} firestoreCollectionName - The name of the Firestore collection.
         * @param {string|null} userId - The user ID if the collection is user-specific, null for public.
         */
        async function migrateLocalStorageToFirestore(localStorageKey, migrationFlagKey, firestoreCollectionName, userId = null) {
            if (localStorage.getItem(migrationFlagKey) === 'true') {
                console.log(`Migration for ${localStorageKey} already completed.`);
                return;
            }

            const storedData = localStorage.getItem(localStorageKey);
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    if (Array.isArray(data) && data.length > 0) {
                        console.log(`Migrating ${data.length} items from ${localStorageKey} to Firestore...`);
                        const collectionRef = collection(window.db, getCollectionPath(firestoreCollectionName, userId));
                        for (const item of data) {
                            // Use the book's workKey as document ID for consistency and deduplication
                            // For alerts, use a unique ID like timestamp
                            const docId = item.workKey || item.id || Date.now().toString() + Math.random().toString(36).substring(2, 8);
                            await setDoc(doc(collectionRef, docId), item);
                        }
                        localStorage.setItem(migrationFlagKey, 'true');
                        localStorage.removeItem(localStorageKey); // Clear local storage after successful migration
                        console.log(`Migration for ${localStorageKey} completed and local data cleared.`);
                    }
                } catch (e) {
                    console.error(`Error during migration of ${localStorageKey}:`, e);
                }
            }
        }

        // --- Firestore Data Operations ---

        /**
         * Adds or updates a book in a specified Firestore collection.
         * Uses the book's workKey as the document ID for idempotency.
         * @param {Object} book - The book object to add/update.
         * @param {string} collectionName - The name of the Firestore collection.
         * @param {string|null} userId - The user ID if the collection is user-specific, null for public.
         */
        async function setBookInFirestore(book, collectionName, userId = null) {
            if (!window.db) { console.error("Firestore DB not initialized."); return; }
            if (!book.workKey) { console.error("Book missing workKey, cannot save to Firestore:", book); return; }
            // Ensure userId is provided for user-specific collections
            const userSpecificCollections = ['flagged_books', 'admin_alerts', 'admin_pending_recs', 'admin_approved_books', 'negative_feedback'];
            if (userSpecificCollections.includes(collectionName) && userId === null) {
                // For this PIN-based system, all admin-specific data will use BETH_FIREBASE_USER_ID
                userId = window.adminUserId;
            }


            try {
                const docRef = doc(window.db, getCollectionPath(collectionName, userId), book.workKey); // Pass book.workKey as doc ID
                await setDoc(docRef, book);
                console.log(`Firestore: Book "${book.title}" added/updated in "${collectionName}" with workKey: ${book.workKey}`);
            } catch (e) {
                console.error(`Error setting book in ${collectionName}:`, e);
            }
        }

        /**
         * Deletes a book from a specified Firestore collection.
         * @param {string} workKey - The workKey of the book to delete.
         * @param {string} collectionName - The name of the Firestore collection.
         * @param {string|null} userId - The user ID if the collection is user-specific, null for public.
         */
        async function deleteBookFromFirestore(workKey, collectionName, userId = null) {
            if (!window.db) { console.error("Firestore DB not initialized."); return; }
            if (!workKey) { console.error("Missing workKey, cannot delete from Firestore."); return; }
            // Ensure userId is provided for user-specific collections
            const userSpecificCollections = ['flagged_books', 'admin_alerts', 'admin_pending_recs', 'admin_approved_books', 'negative_feedback'];
            if (userSpecificCollections.includes(collectionName) && userId === null) {
                // For this PIN-based system, all admin-specific data will use BETH_FIREBASE_USER_ID
                userId = window.adminUserId;
            }

            try {
                const docRef = doc(window.db, getCollectionPath(collectionName, userId), workKey); // Pass workKey as doc ID
                await deleteDoc(docRef);
                console.log(`Firestore: Book with workKey ${workKey} deleted from "${collectionName}".`);
            } catch (e) {
                console.error(`Error deleting book from ${collectionName}:`, e);
            }
        }

        /**
         * Adds an alert to the admin_alerts collection.
         * @param {Object} alert - The alert object to add.
         * @returns {Promise<Object|null>} A promise that resolves to the added alert object with its Firestore ID, or null on error.
         */
        async function addAdminAlertToFirestore(alert) {
            if (!window.db) { console.error("Firestore DB not initialized for alert."); return null; }
            if (!window.adminUserId) { console.error("Admin User ID not initialized for alert. Cannot add alert."); return null; }
            try {
                const collectionRef = collection(window.db, getCollectionPath('admin_alerts', window.adminUserId));
                // Use addDoc for alerts and capture the Firestore-generated ID
                const docRef = await addDoc(collectionRef, alert);
                console.log(`Firestore: Admin alert added with ID: ${docRef.id}`, alert);
                return { id: docRef.id, ...alert }; // Return alert with its new Firestore ID
            } catch (e) {
                console.error("Error adding admin alert to Firestore:", e);
                return null;
            }
        }

        /**
         * Deletes an alert from the admin_alerts collection.
         * @param {string} docId - The document ID of the alert to delete.
         */
        async function deleteAdminAlertFromFirestore(docId) {
            if (!window.db) { console.error("Firestore DB not initialized for alert deletion."); return; }
            if (!window.adminUserId) { console.error("Admin User ID not initialized for alert deletion. Cannot delete alert."); return; }
            try {
                const docRef = doc(window.db, getCollectionPath('admin_alerts', window.adminUserId), docId);
                await deleteDoc(docRef);
                console.log(`Firestore: Admin alert with ID ${docId} deleted.`);
            } catch (e) {
                console.error(`Error deleting admin alert from Firestore (ID: ${docId}):`, e);
            }
        }

        /**
         * Adds a negative feedback term to the negative_feedback collection.
         * @param {string} term - The term to add.
         */
        async function addNegativeFeedbackToFirestore(term) {
            if (!window.db) { console.error("Firestore DB not initialized for negative feedback."); return; }
            if (!window.adminUserId) { console.error("Admin User ID not initialized for negative feedback. Cannot add term."); return; }
            try {
                const collectionRef = collection(window.db, getCollectionPath('negative_feedback', window.adminUserId));
                // Use the term itself as the document ID for uniqueness
                await setDoc(doc(collectionRef, term), { term: term });
                console.log(`Firestore: Negative feedback term "${term}" added.`);
            } catch (e) {
                console.error("Error adding negative feedback to Firestore:", e);
            }
        }

        /**
         * Retrieves Beth's negative feedback terms from Firestore.
         * This is a read-once function, as the data is small and not frequently updated.
         * @returns {Promise<Array<string>>} An array of strings (feedback terms).
         */
        async function getNegativeFeedbackFromFirestore() {
            if (!window.db) {
                console.warn("Firestore DB not initialized, cannot fetch negative feedback.");
                return [];
            }
            if (!window.adminUserId) {
                console.warn("Admin User ID not initialized, cannot fetch negative feedback.");
                return [];
            }
            try {
                const collectionRef = collection(window.db, getCollectionPath('negative_feedback', window.adminUserId));
                const querySnapshot = await getDocs(collectionRef);
                const feedbackTerms = [];
                querySnapshot.forEach(doc => {
                    feedbackTerms.push(doc.data().term);
                });
                console.log("Firestore: Fetched negative feedback terms:", feedbackTerms);
                return feedbackTerms;
            } catch (e) {
                console.error("Error fetching negative feedback from Firestore:", e);
                return [];
            }
        }


        // --- Firestore Real-time Listeners ---

        function setupFirestoreListeners() {
            if (!window.db) {
                console.error("Firestore DB not available for setting up listeners.");
                return;
            }
            if (!window.adminUserId) {
                console.error("Admin User ID not available for setting up listeners. User-specific collections will not be listened to.");
                // We can still set up public listeners, but log the warning.
            }
            console.log("Firestore: Setting up real-time listeners...");

            // Recommended Books (Public)
            onSnapshot(collection(window.db, getCollectionPath('recommended_books')), (snapshot) => {
                window.recommendedBooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                console.log("Firestore Listener: recommended_books updated.", window.recommendedBooks.length, "books.");
                displayRecommendedBooks();
            });

            // Bookshelf Books (Public)
            onSnapshot(collection(window.db, getCollectionPath('bookshelf_books')), (snapshot) => {
                window.bookShelfBooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                console.log("Firestore Listener: bookshelf_books updated.", window.bookShelfBooks.length, "books.");
                displayBookShelfBooks();
            });

            // Beth's Deleted Books (Public)
            onSnapshot(collection(window.db, getCollectionPath('beth_deleted_books')), (snapshot) => {
                window.bethDeletedBooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                console.log("Firestore Listener: beth_deleted_books updated.", window.bethDeletedBooks.length, "books.");
                displayBethsDeletedBooks();
            });

            // Admin-specific listeners (only if adminUserId is available)
            if (window.adminUserId) {
                // Flagged Books (Admin Specific)
                onSnapshot(collection(window.db, getCollectionPath('flagged_books', window.adminUserId)), (snapshot) => {
                    window.flaggedBooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("Firestore Listener: flagged_books updated.", window.flaggedBooks.length, "books.");
                    displayFlaggedBooks();
                });

                // Admin Alerts (Admin Specific)
                onSnapshot(collection(window.db, getCollectionPath('admin_alerts', window.adminUserId)), (snapshot) => {
                    window.adminAlerts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("Firestore Listener: admin_alerts updated.", window.adminAlerts.length, "alerts.", window.adminAlerts);
                    displayAdminAlerts();
                });

                // Admin Pending Recommendations (Admin Specific)
                onSnapshot(collection(window.db, getCollectionPath('admin_pending_recs', window.adminUserId)), (snapshot) => {
                    window.adminPendingRecommendations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    // Sort by score in descending order
                    window.adminPendingRecommendations.sort((a, b) => b.score - a.score);
                    console.log("Firestore Listener: admin_pending_recs updated.", window.adminPendingRecommendations.length, "recs."); // Log for debugging
                    displayAdminPendingRecommendations();
                });

                // Admin Approved Books (Admin Specific)
                onSnapshot(collection(window.db, getCollectionPath('admin_approved_books', window.adminUserId)), (snapshot) => {
                    window.adminApprovedBooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("Firestore Listener: admin_approved_books updated.", window.adminApprovedBooks.length, "books."); // Log for debugging
                    displayAdminApprovedBooks();
                });
            } else {
                console.warn("Skipping setup for user-specific Firestore listeners as adminUserId is not available.");
            }
        }


        // Your email address where you want to receive notifications (currently unused, but kept for potential future use)
        const YOUR_EMAIL_ADDRESS = 'mburkey337@gmail.com';

        // Keywords for Beth's favorite genres for NYT Best Sellers (used in AI prompt and scoring)
        const BETH_GENRE_KEYWORDS = ['true crime', 'murder mystery', 'thriller', 'mystery', 'crime'];

        // Minimum publication year for recommendations (e.g., 2000 to exclude very old books)
        const MIN_PUBLISH_YEAR = 2000;

        // --- Open Library API Constants ---
        const OPEN_LIBRARY_SEARCH_URL = 'https://openlibrary.org/search.json?q=';
        const OPEN_LIBRARY_WORK_URL = 'https://openlibrary.org/works/';
        const OPEN_LIBRARY_COVER_URL = 'https://covers.openlibrary.org/b/id/'; // Base URL for book covers

        /**
         * Escapes a string for safe use in HTML attributes (e.g., data-attributes).
         * @param {string} str - The string to escape.
         * @returns {string} The escaped string.
         */
        function escapeHtmlAttribute(str) {
            if (typeof str !== 'string') {
                str = String(str);
            }
            return str.replace(/&/g, '&amp;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#x27;') // Use &#x27; for single quotes in double-quoted attributes
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;');
        }

        /**
         * Escapes a string for safe use in JavaScript strings within HTML onclick attributes.
         * @param {string} str - The string to escape.
         * @returns {string} The escaped string.
         */
        function escapeJsStringForHtmlAttribute(str) {
            if (typeof str !== 'string') {
                str = String(str);
            }
            // Escape backslashes first to prevent them from escaping other characters
            return str.replace(/\\/g, '\\\\') // Escape backslashes
                      .replace(/'/g, "\\'")   // Escape single quotes
                      .replace(/`/g, "\\`")   // Escape backticks
                      .replace(/\n/g, "\\n")   // Escape newlines
                      .replace(/\r/g, "\\r")   // Escape carriage returns
                      .replace(/\u2028/g, '\\u2028') // Escape line separator
                      .replace(/\u2029/g, '\\u2029'); // Escape paragraph separator
        }

        /**
         * Fetches full book details from Open Library's /works/{key}.json endpoint.
         * Applies filters for cover image presence and minimum publication year.
         * @param {string} workKey - The Open Library work key (e.g., "OL12345W").
         * @returns {Promise<Object|null>} A promise that resolves to the book details object or null if not found/filtered.
         */
        async function fetchBookDetailsFromOpenLibrary(workKey) {
            if (!workKey) {
                console.warn(`fetchBookDetailsFromOpenLibrary: No workKey provided.`);
                return null;
            }
            try {
                const response = await fetch(`${OPEN_LIBRARY_WORK_URL}${workKey}.json`);
                if (!response.ok) {
                    console.warn(`WARNING: Failed to fetch full details for work ${workKey}: ${response.status} - ${response.statusText}`);
                    return null;
                }
                const data = await response.json();
                console.log(`DEBUG: Full details for ${workKey}:`, data);

                // Filter out books without covers
                if (!data.covers || data.covers.length === 0) {
                    console.log(`DEBUG: Skipping "${data.title}" (workKey: ${workKey}) - no cover image available.`);
                    return null;
                }

                // Ensure first_publish_year is a number or null
                const firstPublishYear = data.first_publish_year && typeof data.first_publish_year === 'number' ? data.first_publish_year : null;

                // Filter out books older than MIN_PUBLISH_YEAR
                if (firstPublishYear && firstPublishYear < MIN_PUBLISH_YEAR) {
                    console.log(`DEBUG: Skipping "${data.title}" (workKey: ${workKey}) - published in ${firstPublishYear}, which is older than ${MIN_PUBLISH_YEAR}.`);
                    return null;
                }

                let description = '';
                if (data.description) {
                    if (typeof data.description === 'object' && data.description.value) {
                        description = data.description.value;
                    } else if (typeof data.description === 'string') {
                        description = data.description;
                    }
                }

                // Attempt to get author name from authors array, or use a placeholder
                let authorName = 'Unknown Author';
                if (data.authors && data.authors.length > 0 && data.authors[0].author && data.authors[0].author.key) {
                    const authorKey = data.authors[0].author.key;
                    const authorResponse = await fetch(`https://openlibrary.org${authorKey}.json`);
                    if (authorResponse.ok) {
                        const authorData = await authorResponse.json();
                        authorName = authorData.name || 'Unknown Author';
                    }
                } else if (data.by_statement) { // Fallback to by_statement if authors array is missing
                    authorName = data.by_statement;
                }

                // Construct image URL from covers array (already checked for existence above)
                let imageUrl = `${OPEN_LIBRARY_COVER_URL}${data.covers[0]}-M.jpg`;

                return {
                    title: data.title || 'Unknown Title',
                    author: authorName,
                    description: description,
                    imageUrl: imageUrl,
                    goodreadsUrl: `https://openlibrary.org${data.key}`, // Use Open Library work URL
                    rating: data.ratings_average && typeof data.ratings_average === 'number' ? data.ratings_average : null, // Ensure rating is number or null
                    subjects: data.subjects || [],
                    source: 'Open Library Work Details',
                    first_publish_year: firstPublishYear, // Use the cleaned publish year
                    workKey: workKey // Crucial for Firestore document ID
                };
            }
            catch (error) {
                console.error(`ERROR: Error fetching full details for work ${workKey}:`, error);
                return null;
            }
        }

        /**
         * Searches for books on Open Library based on a query.
         * Displays results in the admin search panel.
         * @param {string} query - The search query (title or author).
         */
        async function searchBooks(query) {
            const loader = document.getElementById('search-loader');
            const message = document.getElementById('search-message');
            const searchResultsContainer = document.getElementById('search-results');

            searchResultsContainer.innerHTML = ''; // Clear previous results
            message.classList.add('hidden');
            loader.style.display = 'block'; // Show loader

            // Prevent searching with URLs
            if (query.startsWith('http://') || query.startsWith('https://')) {
                loader.style.display = 'none';
                message.textContent = 'Please enter only the book title or author, not a full URL.';
                message.classList.remove('hidden');
                return;
            }

            try {
                const response = await fetch(`${OPEN_LIBRARY_SEARCH_URL}${encodeURIComponent(query)}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                loader.style.display = 'none'; // Hide loader
                console.log('DEBUG: Open Library Search Raw Data:', data);

                let processedResults = [];
                for (const bookData of data.docs) {
                    // Basic data integrity check (key, author, cover)
                    if (!bookData.key || !(bookData.author_name || bookData.author) || !bookData.cover_i) {
                        console.log(`DEBUG: Skipping "${bookData.title}" - missing essential Open Library search data or cover.`);
                        continue;
                    }

                    const workKeyMatch = bookData.key.match(/\/works\/(OL\d+W)/);
                    let fullBookDetails = null;
                    if (workKeyMatch && workKeyMatch[1]) {
                        fullBookDetails = await fetchBookDetailsFromOpenLibrary(workKeyMatch[1]);
                    }

                    if (fullBookDetails) { // fullBookDetails will be null if it failed any internal filters (cover, year)
                        processedResults.push(fullBookDetails);
                    } else {
                        console.log(`DEBUG: Skipping "${bookData.title}" - failed to fetch full details or full details were invalid/filtered.`);
                    }
                }

                if (processedResults.length > 0) {
                    displaySearchResults(processedResults);
                } else {
                    message.textContent = 'No books found. Try a different search term.';
                    message.classList.remove('hidden');
                }
            }
            catch (error) {
                console.error('Error fetching books from Open Library:', error);
                loader.style.display = 'none'; // Hide loader
                message.textContent = 'Failed to load search results. Please try again later.';
                message.classList.remove('hidden');
            }
        }

        /**
         * Displays search results in the admin search panel.
         * @param {Array<Object>} results - An array of book objects to display.
         */
        function displaySearchResults(results) {
            const searchResultsContainer = document.getElementById('search-results');
            searchResultsContainer.innerHTML = ''; // Clear previous results
            console.log('DEBUG: Displaying Search Results:', results);

            // Limit to top 10 results for cleaner display
            const resultsArray = Array.isArray(results) ? results : Array.from(results);

            resultsArray.slice(0, 10).forEach(bookData => {
                const title = bookData.title || 'Unknown Title';
                const author = bookData.author || 'Unknown Author';
                const firstPublishYear = bookData.first_publish_year || 'N/A';
                const bookUrl = bookData.goodreadsUrl || '#'; // Using goodreadsUrl to store Open Library work URL

                const sourceTag = bookData.source ? `<span class="source-tag">${bookData.source}</span>` : '';

                const imageUrl = bookData.imageUrl || 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover';
                const descriptionText = bookData.description || 'No description available.';

                // Stringify the entire bookData object and HTML-escape it for the data attribute
                const bookDataJsonString = escapeHtmlAttribute(JSON.stringify(bookData));

                const bookCard = document.createElement('div');
                bookCard.className = 'book-card bg-white rounded-lg shadow-md overflow-hidden flex flex-col';

                bookCard.innerHTML = `
                    <a href="${escapeJsStringForHtmlAttribute(bookUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                        <img src="${escapeJsStringForHtmlAttribute(imageUrl)}" alt="${escapeJsStringForHtmlAttribute(title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover';">
                        <div class="p-6 flex flex-col flex-grow">
                            <h3 class="text-xl font-semibold text-gray-900 mb-2">${escapeJsStringForHtmlAttribute(title)}</h3>
                            <p class="text-gray-600 text-sm mb-2">by ${escapeJsStringForHtmlAttribute(author)}</p>
                            <p class="text-gray-600 text-xs mb-4">First Published: ${escapeJsStringForHtmlAttribute(firstPublishYear)}</p>
                            <p class="text-gray-700 text-base book-description flex-grow">${escapeJsStringForHtmlAttribute(descriptionText)}</p>
                            ${sourceTag}
                        </div>
                    </a>
                    <div class="p-6 pt-0">
                        <button class="action-button w-full add-to-curated-list-btn" data-book-json="${bookDataJsonString}">Add to Beth's Club</button>
                    </div>
                `;
                searchResultsContainer.appendChild(bookCard);
            });

            // Attach event listeners to the newly created buttons
            searchResultsContainer.querySelectorAll('.add-to-curated-list-btn').forEach(button => {
                button.addEventListener('click', addBookToCuratedList);
            });
        }

        /**
         * Displays the current list of recommended books.
         * Filters out books already picked, loved, liked, or passed by Beth.
         */
        function displayRecommendedBooks() {
            // Data is now sourced from window.recommendedBooks (updated by Firestore listener)
            const bookListContainer = document.getElementById('book-list');
            const noBooksMessage = document.getElementById('no-books-message');
            const recommendedHeading = document.getElementById('recommended-reads-heading');
            // Check if the admin panel is currently visible to determine admin mode
            const isAdminMode = !document.getElementById('admin-search-panel')?.classList.contains('hidden');
            
            console.log("displayRecommendedBooks: Called.");

            const date = new Date();
            const month = date.toLocaleString('default', { month: 'long' });
            const year = date.getFullYear();
            if (recommendedHeading) {
                recommendedHeading.textContent = `Recommended Reads (${month} ${year})`;
                console.log("displayRecommendedBooks: Updated heading.");
            }

            if (bookListContainer) {
                bookListContainer.innerHTML = ''; // Clear existing content
            } else {
                console.error("ERROR: 'book-list' element not found. Cannot display recommended books.");
                return; // Exit if container not found
            }

            // Filter out books that are already on the bookshelf (rated 'like', 'love', 'picked', or 'passed')
            const booksToDisplay = window.recommendedBooks.filter(book => book.userRating !== 'like' && book.userRating !== 'love' && book.userRating !== 'picked' && book.userRating !== 'passed');
            console.log("displayRecommendedBooks: Books to display after filtering:", booksToDisplay.length);


            if (booksToDisplay.length === 0) {
                if (noBooksMessage) {
                    noBooksMessage.classList.remove('hidden');
                    noBooksMessage.textContent = "No books recommended yet. New recommendations will be added soon!";
                    console.log("displayRecommendedBooks: Showing no-books-message.");
                }
            } else {
                if (noBooksMessage) {
                    noBooksMessage.classList.add('hidden');
                    console.log("displayRecommendedBooks: Hiding no-books-message.");
                }
                
                booksToDisplay.forEach((book, index) => {
                    const bookCard = document.createElement('div');
                    // Apply animation delay for staggered effect
                    bookCard.className = `book-card bg-white rounded-lg shadow-md overflow-hidden flex flex-col`;
                    bookCard.style.animationDelay = `${index * 0.1}s`; // Stagger animation

                    const description = book.description || 'No description available.';

                    // Admin remove button for recommended reads and Red Flag button (only shown in admin mode)
                    const adminActionsHtml = isAdminMode ? `
                        <button class="remove-admin-button" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Remove from Club</button>
                        <button class="action-button red-flag-btn w-full mt-2" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}" data-author="${escapeJsStringForHtmlAttribute(book.author)}">ðŸš© Red Flag</button>
                    ` : '';

                    // Stringify the entire book object and HTML-escape it for the data attribute
                    const bookJsonString = escapeHtmlAttribute(JSON.stringify(book));

                    bookCard.innerHTML = `
                        <a href="${escapeJsStringForHtmlAttribute(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                            <img src="${escapeJsStringForHtmlAttribute(book.imageUrl)}" alt="${escapeJsStringForHtmlAttribute(book.title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover';">
                            <div class="p-6 flex flex-col flex-grow">
                                <h3 class="text-xl font-semibold text-gray-900 mb-2">${escapeJsStringForHtmlAttribute(book.title)}</h3>
                                <p class="text-gray-600 text-sm mb-2">by ${escapeJsStringForHtmlAttribute(book.author)}</p>
                                ${book.rating !== null ? getStarRatingHtml(book.rating) : ''}
                                <p class="text-gray-700 text-base book-description flex-grow">${escapeJsStringForHtmlAttribute(description)}</p>
                            </div>
                        </a>
                        <div class="p-6 pt-0 flex flex-col items-center">
                            <button class="action-button w-full mb-4 pick-book-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Click to Pick!</button>
                            <button class="action-button insight-btn w-full mb-4 get-insight-btn" data-book-json="${bookJsonString}">âœ¨ Why for Me?</button>
                            <button class="action-button pass-btn w-full pass-book-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Pass</button>
                            ${adminActionsHtml}
                        </div>
                    `;
                    bookListContainer.appendChild(bookCard);
                });

                // Attach event listeners to the newly created buttons
                bookListContainer.querySelectorAll('.pick-book-btn').forEach(button => {
                    button.addEventListener('click', (event) => handlePickBook(event.currentTarget.dataset.workkey));
                });
                bookListContainer.querySelectorAll('.get-insight-btn').forEach(button => {
                    button.addEventListener('click', getPersonalizedInsight);
                });
                bookListContainer.querySelectorAll('.pass-book-btn').forEach(button => {
                    button.addEventListener('click', (event) => handlePassBook(event.currentTarget.dataset.workkey));
                });
                if (isAdminMode) {
                    bookListContainer.querySelectorAll('.remove-admin-button').forEach(button => {
                        button.addEventListener('click', (event) => removeBookFromRecommended(event.currentTarget.dataset.workkey));
                    });
                    bookListContainer.querySelectorAll('.red-flag-btn').forEach(button => {
                        button.addEventListener('click', (event) => handleRedFlag(event.currentTarget.dataset.workkey, event.currentTarget.dataset.author));
                    });
                }
            }
        }

        /**
         * Removes a book from the main recommended list (admin action).
         * @param {string} bookWorkKey - The workKey of the book to remove.
         */
        async function removeBookFromRecommended(bookWorkKey) {
            const bookToRemove = window.recommendedBooks.find(book => book.workKey === bookWorkKey);
            if (bookToRemove) {
                await deleteBookFromFirestore(bookWorkKey, 'recommended_books');
                showMessage(`"${bookToRemove.title}" has been removed from Recommended Reads.`, false, false);
            }
        }

        /**
         * Displays books currently on Beth's bookshelf.
         * Includes options to update ratings or remove from bookshelf.
         */
        function displayBookShelfBooks() {
            // Data is now sourced from window.bookShelfBooks
            const bookshelfListContainer = document.getElementById('bookshelf-list');
            const noBookshelfMessage = document.getElementById('no-bookshelf-message');
            
            if (bookshelfListContainer) {
                bookshelfListContainer.innerHTML = ''; // Clear existing content
            } else {
                console.error("ERROR: 'bookshelf-list' element not found. Cannot display bookshelf books.");
                return; // Exit if container not found
            }

            console.log("displayBookShelfBooks: Called. Books in bookshelf:", window.bookShelfBooks.length);

            if (window.bookShelfBooks.length === 0) {
                if (noBookshelfMessage) {
                    noBookshelfMessage.classList.remove('hidden');
                }
            } else {
                if (noBookshelfMessage) {
                    noBookshelfMessage.classList.add('hidden');
                }
                window.bookShelfBooks.forEach((book, index) => {
                    const bookCard = document.createElement('div');
                    // Apply animation delay for staggered effect and add new class for smaller size
                    bookCard.className = `book-card bookshelf-card-small bg-white rounded-lg shadow-md overflow-hidden flex flex-col`;
                    bookCard.style.animationDelay = `${index * 0.05}s`; // Faster stagger for more items

                    const description = book.description || 'No description available.';
                    let userRatingDisplay = '';
                    let reviewButtonsHtml = '';

                    // Determine display text and button states based on userRating
                    if (book.userRating === 'picked') {
                        userRatingDisplay = 'Picked to read!';
                        reviewButtonsHtml = `
                            <p class="text-gray-600 text-sm mb-2">After reading, how was it?</p>
                            <div class="review-buttons" data-book-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">
                                <button class="review-button update-rating-btn" data-rating="mid">Mid</button>
                                <button class="review-button update-rating-btn" data-rating="like">Like</button>
                                <button class="review-button update-rating-btn" data-rating="love">Love</button>
                            </div>
                        `;
                    } else if (book.userRating === 'mid') {
                        userRatingDisplay = 'You thought this was Mid.';
                        reviewButtonsHtml = `
                            <p class="text-gray-600 text-sm mb-2">Change your rating?</p>
                            <div class="review-buttons" data-book-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">
                                <button class="review-button selected-mid update-rating-btn" data-rating="mid">Mid</button>
                                <button class="review-button update-rating-btn" data-rating="like">Like</button>
                                <button class="review-button update-rating-btn" data-rating="love">Love</button>
                            </div>
                        `;
                    } else if (book.userRating === 'like') {
                        userRatingDisplay = 'You Liked this!';
                        reviewButtonsHtml = `
                            <p class="text-gray-600 text-sm mb-2">Change your rating?</p>
                            <div class="review-buttons" data-book-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">
                                <button class="review-button update-rating-btn" data-rating="mid">Mid</button>
                                <button class="review-button selected-like update-rating-btn" data-rating="like">Like</button>
                                <button class="review-button update-rating-btn" data-rating="love">Love</button>
                            </div>
                        `;
                    } else if (book.userRating === 'love') {
                        userRatingDisplay = 'You Loved this!';
                        reviewButtonsHtml = `
                            <p class="text-gray-600 text-sm mb-2">Change your rating?</p>
                            <div class="review-buttons" data-book-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">
                                <button class="review-button update-rating-btn" data-rating="mid">Mid</button>
                                <button class="review-button update-rating-btn" data-rating="like">Like</button>
                                <button class="review-button selected-love update-rating-btn" data-rating="love">Love</button>
                            </div>
                        `;
                    }

                    bookCard.innerHTML = `
                        <a href="${escapeJsStringForHtmlAttribute(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                            <img src="${escapeJsStringForHtmlAttribute(book.imageUrl)}" alt="${escapeJsStringForHtmlAttribute(book.title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover';">
                            <div class="p-6 flex flex-col flex-grow">
                                <h3 class="text-xl font-semibold text-gray-900 mb-2">${escapeJsStringForHtmlAttribute(book.title)}</h3>
                                <p class="text-gray-600 text-sm mb-2">by ${escapeJsStringForHtmlAttribute(book.author)}</p>
                                ${book.rating !== null ? getStarRatingHtml(book.rating) : ''}
                                <p class="text-gray-700 text-base book-description flex-grow">${escapeJsStringForHtmlAttribute(description)}</p>
                            </div>
                        </a>
                        <div class="p-6 pt-0 flex flex-col items-center">
                            <p class="text-gray-700 text-lg font-semibold mt-2">${userRatingDisplay}</p>
                            ${reviewButtonsHtml}
                            <button class="text-red-500 hover:text-red-700 text-sm font-medium mt-4 remove-from-bookshelf-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Remove from Bookshelf</button>
                        </div>
                    `;
                    bookshelfListContainer.appendChild(bookCard);
                });

                // Attach event listeners to the newly created buttons
                bookshelfListContainer.querySelectorAll('.update-rating-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const workKey = event.currentTarget.closest('.review-buttons').dataset.bookWorkkey;
                        const rating = event.currentTarget.dataset.rating;
                        updateUserRating(workKey, rating);
                    });
                });
                bookshelfListContainer.querySelectorAll('.remove-from-bookshelf-btn').forEach(button => {
                    button.addEventListener('click', (event) => removeBookFromBookshelf(event.currentTarget.dataset.workkey));
                });
            }
        }

        /**
         * Displays books Beth has personally deleted from her bookshelf.
         */
        function displayBethsDeletedBooks() {
            // Data is now sourced from window.bethDeletedBooks
            const bethDeletedBooksListContainer = document.getElementById('beth-deleted-books-list');
            const noBethDeletedBooksMessage = document.getElementById('no-beth-deleted-books-message');
            
            if (bethDeletedBooksListContainer) {
                bethDeletedBooksListContainer.innerHTML = ''; // Clear existing content
            } else {
                console.error("ERROR: 'beth-deleted-books-list' element not found. Cannot display Beth's deleted books.");
                return; // Exit if container not found
            }

            console.log("displayBethsDeletedBooks: Called. Books in deleted list:", window.bethDeletedBooks.length);

            if (window.bethDeletedBooks.length === 0) {
                if (noBethDeletedBooksMessage) {
                    noBethDeletedBooksMessage.classList.remove('hidden');
                }
            } else {
                if (noBethDeletedBooksMessage) {
                    noBethDeletedBooksMessage.classList.add('hidden');
                }
                window.bethDeletedBooks.forEach((book, index) => {
                    const bookCard = document.createElement('div');
                    bookCard.className = `book-card bookshelf-card-small bg-white rounded-lg shadow-md overflow-hidden flex flex-col`;
                    bookCard.style.animationDelay = `${index * 0.05}s`;

                    const description = book.description || 'No description available.';

                    bookCard.innerHTML = `
                        <a href="${escapeJsStringForHtmlAttribute(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                            <img src="${escapeJsStringForHtmlAttribute(book.imageUrl)}" alt="${escapeJsStringForHtmlAttribute(book.title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover';">
                            <div class="p-6 flex flex-col flex-grow">
                                <h3 class="text-xl font-semibold text-gray-900 mb-2">${escapeJsStringForHtmlAttribute(book.title)}</h3>
                                <p class="text-gray-600 text-sm mb-2">by ${escapeJsStringForHtmlAttribute(book.author)}</p>
                                ${book.rating !== null ? getStarRatingHtml(book.rating) : ''}
                                <p class="text-gray-700 text-base book-description flex-grow">${escapeJsStringForHtmlAttribute(description)}</p>
                            </div>
                        </a>
                        <div class="p-6 pt-0 flex flex-col items-center">
                            <button class="action-button w-full mt-4 restore-beth-deleted-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Restore to Bookshelf</button>
                        </div>
                    `;
                    bethDeletedBooksListContainer.appendChild(bookCard);
                });

                // Attach event listeners to the newly created buttons
                bethDeletedBooksListContainer.querySelectorAll('.restore-beth-deleted-btn').forEach(button => {
                    button.addEventListener('click', (event) => restoreBookFromBethDeleted(event.currentTarget.dataset.workkey));
                });
            }
        }

        /**
         * Displays books that have been flagged by the admin (passed or red-flagged).
         */
        function displayFlaggedBooks() {
            // Data is now sourced from window.flaggedBooks
            const flaggedBooksListContainer = document.getElementById('flagged-books-list');
            const noFlaggedBooksMessage = document.getElementById('no-flagged-books-message');
            
            if (flaggedBooksListContainer) {
                flaggedBooksListContainer.innerHTML = ''; // Clear existing content
            } else {
                console.error("ERROR: 'flagged-books-list' element not found. Cannot display flagged books.");
                return; // Exit if container not found
            }

            console.log("displayFlaggedBooks: Called. Books in flagged list:", window.flaggedBooks.length);

            if (window.flaggedBooks.length === 0) {
                if (noFlaggedBooksMessage) {
                    noFlaggedBooksMessage.classList.remove('hidden');
                }
            } else {
                if (noFlaggedBooksMessage) {
                    noFlaggedBooksMessage.classList.add('hidden');
                }
                window.flaggedBooks.forEach((book, index) => {
                    const bookCard = document.createElement('div');
                    bookCard.className = `book-card bookshelf-card-small bg-white rounded-lg shadow-md overflow-hidden flex flex-col`;
                    bookCard.style.animationDelay = `${index * 0.05}s`;

                    const description = book.description || 'No description available.';
                    const flaggedReason = book.flaggedReason ? `<p class="text-red-500 text-sm mt-2">Reason: ${escapeHtmlAttribute(book.flaggedReason)}</p>` : '';

                    bookCard.innerHTML = `
                        <a href="${escapeJsStringForHtmlAttribute(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                            <img src="${escapeJsStringForHtmlAttribute(book.imageUrl)}" alt="${escapeJsStringForHtmlAttribute(book.title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover';">
                            <div class="p-6 flex flex-col flex-grow">
                                <h3 class="text-xl font-semibold text-gray-900 mb-2">${escapeJsStringForHtmlAttribute(book.title)}</h3>
                                <p class="text-gray-600 text-sm mb-2">by ${escapeJsStringForHtmlAttribute(book.author)}</p>
                                ${book.rating !== null ? getStarRatingHtml(book.rating) : ''}
                                <p class="text-gray-700 text-base book-description flex-grow">${escapeJsStringForHtmlAttribute(description)}</p>
                                ${flaggedReason}
                            </div>
                        </a>
                        <div class="p-6 pt-0 flex flex-col items-center">
                            <button class="action-button w-full mt-4 restore-flagged-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Restore to Recommendations</button>
                        </div>
                    `;
                    flaggedBooksListContainer.appendChild(bookCard);
                });

                // Attach event listeners to the newly created buttons
                flaggedBooksListContainer.querySelectorAll('.restore-flagged-btn').forEach(button => {
                    button.addEventListener('click', (event) => restoreBookFromFlagged(event.currentTarget.dataset.workkey));
                });
            }
        }

        /**
         * Adds a book (from search results or manual entry) to the main curated recommendation list.
         * @param {Event} event - The click event from the "Add to Beth's Club" button.
         */
        async function addBookToCuratedList(event) {
            const button = event.currentTarget;
            const bookData = JSON.parse(button.dataset.bookJson); // Parse the JSON string back to an object

            // Extract properties from the parsed bookData object
            let { title, author, imageUrl, goodreadsUrl, description, subjects, rating, workKey, first_publish_year } = bookData;

            let descriptionText = description;
            const actualRating = rating !== undefined ? parseFloat(rating) : null;
            const actualFirstPublishYear = first_publish_year !== undefined && typeof first_publish_year === 'number' ? first_publish_year : null;


            // If description is still generic, try to fetch a better one
            if (descriptionText === '' || descriptionText.trim() === '') {
                const workKeyMatch = goodreadsUrl.match(/\/works\/(OL\d+W)/);
                if (workKeyMatch && workKeyMatch[1]) {
                    const fetchedDetails = await fetchBookDetailsFromOpenLibrary(workKeyMatch[1]);
                    if (fetchedDetails) {
                        descriptionText = fetchedDetails.description;
                    }
                }
            }

            const newBook = {
                title: title,
                author: author,
                description: descriptionText, // Now potentially updated
                imageUrl: imageUrl,
                goodreadsUrl: goodreadsUrl,
                rating: actualRating,
                subjects: subjects, // Store subjects
                userRating: null, // Initialize user rating as null
                workKey: workKey, // Crucial for Firestore document ID
                first_publish_year: actualFirstPublishYear // Ensure this is not undefined
            };

            // Check if book already exists in recommendedBooks (Firestore data)
            const isDuplicate = window.recommendedBooks.some(book => book.workKey === newBook.workKey);

            if (!isDuplicate) {
                await setBookInFirestore(newBook, 'recommended_books');
                showMessage(`"${title}" has been added to Beth's Book Club!`, false, false);
                // Re-display search results to reflect the addition (optional, but good for UX)
                displaySearchResults(Array.from(document.getElementById('search-results').children).map(card => JSON.parse(card.querySelector('.add-to-curated-list-btn').dataset.bookJson)));
            } else {
                showMessage(`"${title}" is already in Beth's Book Club!`, false, false);
            }
        }

        /**
         * Manually adds a book to the curated list using an Open Library Work URL (admin action).
         */
        async function addBookFromOpenLibraryUrl() {
            const urlInput = document.getElementById('manual-add-url-input');
            const url = urlInput.value.trim();
            const loader = document.getElementById('search-loader');
            const message = document.getElementById('search-message');

            message.classList.add('hidden');
            loader.style.display = 'block';

            const workKeyMatch = url.match(/\/works\/(OL\d+W)/);
            if (!workKeyMatch || !workKeyMatch[1]) {
                loader.style.display = 'none';
                showMessage('Invalid Open Library Work URL. Please provide a URL like https://openlibrary.org/works/OL12345W', false, false);
                return;
            }

            const workKey = workKeyMatch[1];

            try {
                const bookDetails = await fetchBookDetailsFromOpenLibrary(workKey);

                if (!bookDetails) {
                    loader.style.display = 'none';
                    showMessage('Failed to retrieve book details from the provided Open Library URL. Please check the URL and try again.', false, false);
                    return;
                }

                // Construct the new book object. Note: For manual adds, we bypass some filters.
                const newBook = {
                    title: bookDetails.title,
                    author: bookDetails.author,
                    description: bookDetails.description,
                    imageUrl: bookDetails.imageUrl,
                    goodreadsUrl: bookDetails.goodreadsUrl,
                    rating: bookDetails.rating,
                    subjects: bookDetails.subjects,
                    userRating: null, // Manually added books start with no user rating
                    source: 'Manually Added (Admin)',
                    workKey: bookDetails.workKey, // Crucial for Firestore document ID
                    first_publish_year: bookDetails.first_publish_year // Ensure this is not undefined
                };

                // Check if book already exists in recommendedBooks (Firestore data)
                const isDuplicate = window.recommendedBooks.some(book => book.workKey === newBook.workKey);

                if (!isDuplicate) {
                    await setBookInFirestore(newBook, 'recommended_books');
                    showMessage(`"${newBook.title}" has been manually added to Beth's Book Club!`, false, false);
                    urlInput.value = ''; // Clear input
                    showView('recommendations-view'); // Ensure we are on the recommendations view
                } else {
                    showMessage(`"${newBook.title}" is already in Beth's Book Club!`, false, false);
                }

            }
            catch (error) {
                console.error('ERROR: Error manually adding book from Open Library URL:', error);
                showMessage('An error occurred while trying to add the book. Please try again.', false, false);
            }
            finally {
                loader.style.display = 'none';
            }
        }

        /**
         * Removes a book from Beth's bookshelf and moves it to her deleted books list.
         * @param {string} bookWorkKey - The workKey of the book to remove.
         */
        async function removeBookFromBookshelf(bookWorkKey) {
            const bookToRemove = window.bookShelfBooks.find(book => book.workKey === bookWorkKey);

            if (bookToRemove) {
                await deleteBookFromFirestore(bookWorkKey, 'bookshelf_books'); // Remove from bookshelf
                await setBookInFirestore(bookToRemove, 'beth_deleted_books'); // Add to Beth's deleted list
                showMessage(`"${bookToRemove.title}" has been moved to Beth's Deleted Books.`, false, false);
            }
        }

        /**
         * Restores a book from Beth's deleted books list back to her bookshelf.
         * @param {string} bookWorkKey - The workKey of the book to restore.
         */
        async function restoreBookFromBethDeleted(bookWorkKey) {
            const bookToRestore = window.bethDeletedBooks.find(book => book.workKey === bookWorkKey);

            if (bookToRestore) {
                await deleteBookFromFirestore(bookWorkKey, 'beth_deleted_books'); // Remove from Beth's deleted
                bookToRestore.userRating = 'picked'; // Set to 'picked' so review buttons show
                await setBookInFirestore(bookToRestore, 'bookshelf_books'); // Add back to bookshelf
                showMessage(`"${bookToRestore.title}" has been restored to your Bookshelf!`, false, false);
            }
        }

        /**
         * Restores a book from the admin's flagged list back to the main recommendations.
         * @param {string} bookWorkKey - The workKey of the book to restore.
         */
        async function restoreBookFromFlagged(bookWorkKey) {
            const bookToRestore = window.flaggedBooks.find(book => book.workKey === bookWorkKey);

            if (bookToRestore) {
                await deleteBookFromFirestore(bookWorkKey, 'flagged_books', window.adminUserId); // Remove from flagged
                bookToRestore.userRating = null; // Reset user rating for recommendations
                bookToRestore.flaggedReason = null; // Clear any flagged reason
                await setBookInFirestore(bookToRestore, 'recommended_books'); // Add back to recommendations
                showMessage(`"${bookToRestore.title}" has been restored to Recommended Reads!`, false, false);
            }
        }

        /**
         * Handles the "Pass" button click for Beth. Moves the book to flagged books (admin view).
         * @param {string} bookWorkKey - The workKey of the book to pass.
         */
        async function handlePassBook(bookWorkKey) {
            const bookToPass = window.recommendedBooks.find(book => book.workKey === bookWorkKey);

            if (bookToPass) {
                console.log(`handlePassBook: Beth passed on book with workKey: ${bookWorkKey}`);
                // Send alert BEFORE modifying bookToPass, as sendAdminAlert uses current book data
                await sendAdminAlert('passed_book', bookWorkKey); 
                
                // Updated message for Beth: no reference to admin-only tab
                showMessage(`You've passed on "${bookToPass.title}". You won't see this recommendation again.`, false, false);
                
                await deleteBookFromFirestore(bookWorkKey, 'recommended_books'); // Remove from recommended
                bookToPass.userRating = 'passed'; // Mark as passed
                bookToPass.flaggedReason = 'Passed by user'; // Add a default reason
                await setBookInFirestore(bookToPass, 'flagged_books', window.adminUserId); // Move to flagged books
            }
        }

        /**
         * Handles the "Red Flag" button click. Prompts for a reason and moves the book to flagged.
         * Adds the reason to Beth's negative feedback for AI learning.
         * @param {string} bookWorkKey - The workKey of the book to red flag.
         * @param {string} bookAuthor - The author of the book.
         */
        function handleRedFlag(bookWorkKey, bookAuthor) {
            const bookToFlag = window.recommendedBooks.find(book => book.workKey === bookWorkKey);
            if (!bookToFlag) return;

            const feedbackPrompt = `Why are you flagging "${bookToFlag.title}" by ${bookAuthor}? (e.g., "romance", "magic", "self-help")`;

            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const closeButton = document.getElementById('message-box-close');

            messageText.innerHTML = `
                <p class="mb-4">${feedbackPrompt}</p>
                <input type="text" id="flag-reason-input" placeholder="Enter reason (e.g., 'romance', 'magic')"
                       class="w-full p-2 border border-gray-300 rounded-md mb-4 text-gray-700">
                <button id="submit-flag-reason" class="action-button px-4 py-2 bg-red-600 hover:bg-red-700">Submit Feedback</button>
                <button id="cancel-flag" class="mt-2 px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500">Cancel</button>
            `;
            messageBox.classList.remove('llm-insight');
            closeButton.style.display = 'none'; // Hide default close button

            messageBox.style.display = 'block';

            document.getElementById('submit-flag-reason').addEventListener('click', async () => {
                const reason = document.getElementById('flag-reason-input').value.trim();
                if (reason) {
                    await addNegativeFeedbackToFirestore(reason.toLowerCase());
                    showMessage(`Feedback received: "${reason}". AI will learn from this!`, false, false);
                } else {
                    showMessage('No feedback provided.', false, false);
                }
                messageBox.style.display = 'none'; // Hide the modal

                // Move the book to flagged books
                await deleteBookFromFirestore(bookWorkKey, 'recommended_books');
                bookToFlag.userRating = 'flagged'; // Mark as flagged
                bookToFlag.flaggedReason = reason || 'No reason provided'; // Store the reason
                await setBookInFirestore(bookToFlag, 'flagged_books', window.adminUserId);
            }, { once: true }); // Use { once: true } to prevent multiple listeners

            document.getElementById('cancel-flag').addEventListener('click', () => {
                messageBox.style.display = 'none';
            }, { once: true });
        }

        /**
         * Updates the user's rating for a book (Mid, Like, Love).
         * Moves books between recommended and bookshelf lists as appropriate.
         * @param {string} bookWorkKey - The workKey of the book to rate.
         * @param {string} rating - The new rating ('mid', 'like', 'love', 'picked', 'passed').
         */
        async function updateUserRating(bookWorkKey, rating) {
            let bookToUpdate = window.recommendedBooks.find(book => book.workKey === bookWorkKey);
            let sourceCollection = 'recommended_books';

            if (!bookToUpdate) {
                bookToUpdate = window.bookShelfBooks.find(book => book.workKey === bookWorkKey);
                sourceCollection = 'bookshelf_books';
            }
            if (!bookToUpdate) {
                bookToUpdate = window.flaggedBooks.find(book => book.workKey === bookWorkKey);
                sourceCollection = 'flagged_books';
            }
            if (!bookToUpdate) {
                bookToUpdate = window.bethDeletedBooks.find(book => book.workKey === bookWorkKey);
                sourceCollection = 'beth_deleted_books';
            }

            if (!bookToUpdate) {
                console.error("Book not found in any known collection for update:", bookWorkKey);
                return;
            }

            // Update the rating
            bookToUpdate.userRating = rating;

            // Handle movement between collections
            if (rating === 'like' || rating === 'love' || rating === 'mid' || rating === 'picked') { // 'picked' and 'mid' also stay on bookshelf
                // If it's not already on the bookshelf, add it
                const isAlreadyOnShelf = window.bookShelfBooks.some(book => book.workKey === bookToUpdate.workKey);
                if (!isAlreadyOnShelf) {
                    await setBookInFirestore(bookToUpdate, 'bookshelf_books');
                } else {
                    // If already on shelf, just update its rating
                    await setBookInFirestore(bookToUpdate, 'bookshelf_books');
                }

                // Remove from other collections if it was there
                if (sourceCollection === 'recommended_books') {
                    await deleteBookFromFirestore(bookWorkKey, 'recommended_books');
                } else if (sourceCollection === 'flagged_books') {
                    await deleteBookFromFirestore(bookWorkKey, 'flagged_books', window.adminUserId);
                } else if (sourceCollection === 'beth_deleted_books') {
                    await deleteBookFromFirestore(bookWorkKey, 'beth_deleted_books');
                }
            } else {
                // For other ratings (e.g., 'passed' if handled here, though 'passed' is handled by handlePassBook)
                // Just update the book in its current collection.
                if (sourceCollection === 'recommended_books') {
                    await setBookInFirestore(bookToUpdate, 'recommended_books');
                } else if (sourceCollection === 'bookshelf_books') {
                    await setBookInFirestore(bookToUpdate, 'bookshelf_books');
                } else if (sourceCollection === 'flagged_books') {
                    await setBookInFirestore(bookToUpdate, 'flagged_books', window.adminUserId);
                } else if (sourceCollection === 'beth_deleted_books') {
                    await setBookInFirestore(bookToUpdate, 'beth_deleted_books');
                }
            }

            showMessage(`"${bookToUpdate.title}" rated as "${rating}"!`, false, false);
        }

        /**
         * Calls the LLM to get a critical evaluation (pros, cons, summary) for a given book.
         * @param {Object} bookDetails - The book object to evaluate.
         * @returns {Promise<Object>} A promise that resolves to an object with pros, cons, and summary.
         */
        async function getAIProsConsSummary(bookDetails) {
            const { title, author, description, subjects } = bookDetails;

            const favoriteGenres = BETH_GENRE_KEYWORDS.join(', ');
            // Use window.bookShelfBooks which is updated by Firestore listener
            const lovedBooks = window.bookShelfBooks.filter(b => b.userRating === 'love');
            const likedBooks = window.bookShelfBooks.filter(b => b.userRating === 'like');

            let prompt = `You are an AI assistant evaluating a book for Beth's book club.
            Beth enjoys the following genres: ${favoriteGenres}.`;
            if (lovedBooks.length > 0) {
                prompt += `\nShe has LOVED these books: ${lovedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
            }
            if (likedBooks.length > 0) {
                prompt += `\nShe has LIKED these books: ${likedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
            }
            prompt += `\nHere is the book to evaluate:\n`;
            prompt += `Title: "${title}"\n`;
            prompt += `Author: ${author}\n`;
            if (description && description !== '') {
                prompt += `Description: ${description}\n`;
            }
            if (subjects && subjects.length > 0) {
                prompt += `Subjects/Themes: ${subjects.join(', ')}\n`;
            }
            prompt += `\nPlease provide a critical evaluation of this book's suitability for Beth. Include:
            1. A "Pros" list (why she might like it, connecting to her preferences).
            2. A "Cons" list (potential reasons she might not like it, considering her dislikes and past negative feedback).
            3. A concise "Summary" (2-3 sentences).
            Provide your response as a JSON object with properties: "pros" (array of strings), "cons" (array of strings), "summary" (string).`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "pros": { "type": "ARRAY", "items": { "type": "STRING" } },
                                "cons": { "type": "ARRAY", "items": { "type": "STRING" } },
                                "summary": { "type": "STRING" }
                            },
                            "propertyOrdering": ["pros", "cons", "summary"]
                        }
                    }
                };
                // Use the provided API key or fallback to empty string for Canvas
                const apiKey = "AIzaSyCU2J_0zErEIPLl-3ejBABDM-NYKOg44Zk" || "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                console.log("DEBUG: LLM Evaluation Prompt:", prompt); // Log the prompt
                console.log("DEBUG: LLM Evaluation Payload:", JSON.stringify(payload, null, 2)); // Log the payload

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                let result;
                let rawResponseText = '';
                try {
                    rawResponseText = await response.text();
                    console.log("DEBUG: Raw LLM Evaluation Response Text:", rawResponseText); // Log raw response
                    if (!rawResponseText || rawResponseText.trim() === '') {
                        throw new Error("Empty or whitespace response from Gemini API.");
                    }
                    result = JSON.parse(rawResponseText);
                }
                catch (jsonError) {
                    console.error(`ERROR: Failed to parse LLM evaluation response as JSON:`, jsonError, `Raw response text:`, rawResponseText);
                    return { pros: ['Failed to generate pros.'], cons: ['Failed to generate cons.'], summary: 'Failed to generate summary.' };
                }

                if (!response.ok) {
                    console.error(`ERROR: Gemini API responded with status ${response.status} (evaluation):`, result);
                    return { pros: ['API error generating pros.'], cons: ['API error generating cons.'], summary: 'API error generating summary.' };
                }

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    const evaluation = JSON.parse(jsonString);
                    console.log("DEBUG: Parsed LLM Evaluation:", evaluation); // Log parsed evaluation
                    return evaluation;
                } else {
                    console.error("ERROR: LLM evaluation response structure unexpected or no candidates:", result);
                    return { pros: ['No AI pros generated.'], cons: ['No AI cons generated.'], summary: 'No AI summary generated.' };
                }

            }
            catch (error) {
                console.error('ERROR: Error calling Gemini API for evaluation (network/fetch issue):', error);
                return { pros: ['Network error generating pros.'], cons: ['Network error generating cons.'], summary: 'Network error generating summary.' };
            }
        }

        /**
         * Fetches lightweight trending book candidates from Open Library.
         * Applies basic filters for essential data, cover, and publication year.
         * @param {number} limit - The number of results to request per page.
         * @returns {Promise<Array<Object>>} A promise that resolves to an array of lightweight book candidate objects.
         */
        async function getTrendingOpenLibraryCandidates(limit = 30) {
            let lightweightCandidates = [];
            const baseUrl = 'https://openlibrary.org/search.json?q=trending_score_hourly_sum%3A%5B1+TO+%2A%5D+language%3Aeng&sort=trending';
            const numPagesToFetch = 3; // Fetch multiple pages for more candidates

            for (let i = 0; i < numPagesToFetch; i++) {
                const offset = i * limit;
                const url = `${baseUrl}&offset=${offset}&limit=${limit}`;
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.warn(`WARNING: Failed to fetch trending candidates from Open Library (page ${i + 1}): ${response.status} - ${response.statusText}`);
                        continue;
                    }
                    const data = await response.json();

                    if (data.docs && data.docs.length > 0) {
                        for (const doc of data.docs) {
                            const workKeyMatch = doc.key ? doc.key.match(/\/works\/(OL\d+W)/) : null;
                            // Only add if it has a key, author, cover, valid workKey, and meets min publish year
                            const firstPublishYear = doc.first_publish_year && typeof doc.first_publish_year === 'number' ? doc.first_publish_year : null;

                            if (doc.key && (doc.author_name || doc.author) && doc.cover_i && workKeyMatch && workKeyMatch[1] &&
                                (firstPublishYear && firstPublishYear >= MIN_PUBLISH_YEAR)) { // Use cleaned firstPublishYear
                                lightweightCandidates.push({
                                    title: doc.title || 'Unknown Title',
                                    author: doc.author_name ? doc.author_name.join(', ') : (doc.author || 'Unknown Author'),
                                    description: doc.first_sentence ? doc.first_sentence[0] : '',
                                    imageUrl: doc.cover_i ? `${OPEN_LIBRARY_COVER_URL}${doc.cover_i}-M.jpg` : 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover',
                                    goodreadsUrl: doc.key ? `https://openlibrary.org${doc.key}` : '#',
                                    rating: doc.ratings_average && typeof doc.ratings_average === 'number' ? doc.ratings_average : null,
                                    subjects: doc.subject || [],
                                    workKey: workKeyMatch[1],
                                    source: 'Open Library Trending (Lightweight)',
                                    first_publish_year: firstPublishYear // Use cleaned firstPublishYear
                                });
                            } else {
                                console.log(`DEBUG: Skipping trending candidate "${doc.title}" (workKey: ${doc.key}) - missing essential data, cover, or too old for initial consideration.`);
                            }
                        }
                    }
                }
                catch (error) {
                    console.error(`ERROR: Error fetching trending candidates from Open Library (page ${i + 1}):`, error);
                }
            }
            console.log("getTrendingOpenLibraryCandidates: Found", lightweightCandidates.length, "candidates.");
            return lightweightCandidates;
        }

        /**
         * Calculates a relevance score for a book based on Beth's preferences.
         * This score helps prioritize which books are recommended.
         * @param {Object} book - The book object to score.
         * @param {Array<Object>} lovedBooks - List of books Beth has loved.
         * @param {Array<Object>} likedBooks - List of books Beth has liked.
         * @param {Set<string>} currentSelectedAuthors - Set of authors already selected for the current recommendation batch (to promote diversity).
         * @returns {number} The calculated score (0-100).
         */
        function calculateBookScore(book, lovedBooks, likedBooks, currentSelectedAuthors) {
            let score = 0;
            const titleLower = book.title ? String(book.title).toLowerCase() : '';
            const descriptionLower = book.description ? String(book.description).toLowerCase() : '';
            const authorLower = book.author ? String(book.author).toLowerCase() : '';
            const subjectsLower = book.subjects ? book.subjects.map(s => String(s).toLowerCase()) : [];

            // Get all authors currently on Beth's bookshelf (loved or liked)
            const allBookshelfAuthors = new Set(
                window.bookShelfBooks.map(b => String(b.author).toLowerCase())
            );

            // Base Score
            score += 20;

            // 1. Genre Alignment (BETH_GENRE_KEYWORDS)
            BETH_GENRE_KEYWORDS.forEach(keyword => {
                if (titleLower.includes(keyword) || descriptionLower.includes(keyword) || subjectsLower.some(s => s.includes(keyword))) {
                    score += 10;
                }
            });

            // 2. Bookshelf Affinity (based on loved/liked authors and subjects)
            const allLovedAuthors = new Set(lovedBooks.map(b => String(b.author).toLowerCase()));
            const allLikedAuthors = new Set(likedBooks.map(b => String(b.author).toLowerCase()));
            const allLovedSubjects = new Set(lovedBooks.flatMap(b => b.subjects ? b.subjects.map(s => String(s).toLowerCase()) : []));
            const allLikedSubjects = new Set(likedBooks.flatMap(b => b.subjects ? b.subjects.map(s => String(s).toLowerCase()) : []));

            // Author match
            if (allLovedAuthors.has(authorLower)) {
                score += 25;
            } else if (allLikedAuthors.has(authorLower)) {
                score += 15;
            }

            // Subject overlap
            subjectsLower.forEach(subject => {
                if (allLovedSubjects.has(subject)) {
                    score += 7;
                } else if (allLikedSubjects.has(subject)) {
                    score += 3;
                }
            });

            // 3. Open Library Rating
            if (book.rating && typeof book.rating === 'number') {
                score += book.rating * 3;
            }

            // 4. Source Bonus (prioritize AI and bookshelf-based recommendations)
            if (book.source === 'AI Recommendation') {
                score += 10;
            } else if (book.source.includes('Bookshelf')) {
                score += 8;
            } else if (book.source.includes('Trending')) {
                score += 5;
            }

            // 5. Author Deprioritization (for authors already on Beth's bookshelf)
            // Increased penalty to promote more variety
            if (allBookshelfAuthors.has(authorLower)) {
                score -= 25; // Increased penalty for authors already on Beth's bookshelf
            }

            // 6. Author Deprioritization (within current batch) - to ensure variety in a single recommendation run
            if (currentSelectedAuthors && currentSelectedAuthors.has(authorLower)) {
                score -= 20; // Heavier penalty to ensure diverse authors in one batch
            }

            // Ensure score is between 0 and 100
            score = Math.max(0, Math.min(100, score));

            return score;
        }


        /**
         * Generates new book recommendations using a multi-phase approach:
         * 1. Collects lightweight candidates from various sources (bookshelf-based, AI-powered, trending).
         * 2. Fetches full details for promising candidates.
         * 3. Scores books based on Beth's preferences and filters them.
         * 4. Adds approved recommendations to the admin pending list.
         */
        async function generateRecommendations() {
            const loader = document.getElementById('search-loader');
            const message = document.getElementById('search-message');
            const searchResultsContainer = document.getElementById('search-results');

            if (searchResultsContainer) searchResultsContainer.innerHTML = '';
            if (message) message.classList.add('hidden');
            if (loader) loader.style.display = 'block';
            showMessage('Generating recommendations... This might take a moment.', true, false);
            console.log("generateRecommendations: Initiated.");

            // Send admin alert that recommendation generation has started
            console.log("generateRecommendations: Sending 'recommendations_generation_started' alert.");
            await sendAdminAlert('recommendations_generation_started');

            const TARGET_BOOKS = 6;
            const MIN_SCORE_THRESHOLD = 50; // Minimum score for a book to be recommended
            const AUTO_APPROVE_SCORE_THRESHOLD = 80; // New: Score for automatic approval
            const MAX_CANDIDATE_FETCH_ATTEMPTS = 5; // Max attempts to fetch batches of lightweight candidates
            const OPEN_LIBRARY_LIGHTWEIGHT_LIMIT = 50; // Number of lightweight candidates to fetch per query
            const FULL_DETAIL_FETCH_BATCH_SIZE = 10; // How many full book details to fetch in one go

            let allLightweightCandidates = [];
            const processedWorkKeys = new Set(); // To avoid duplicates and re-fetching full details

            // Collect titles of all existing books to avoid recommending duplicates
            const existingBookWorkKeys = new Set(window.recommendedBooks.map(book => book.workKey));
            window.bookShelfBooks.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.flaggedBooks.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.bethDeletedBooks.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.adminPendingRecommendations.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.adminApprovedBooks.forEach(book => existingBookWorkKeys.add(book.workKey)); // NEW: Include admin approved books


            try {
                // Phase 1: Collect lightweight candidates from various sources
                for (let attempt = 0; attempt < MAX_CANDIDATE_FETCH_ATTEMPTS; attempt++) {
                    console.log(`generateRecommendations: Fetching lightweight candidates - Attempt ${attempt + 1}`);
                    // Get lightweight bookshelf-based candidates
                    const bookshelfCandidates = await getBookshelfBasedRecommendations(OPEN_LIBRARY_LIGHTWEIGHT_LIMIT);
                    allLightweightCandidates = allLightweightCandidates.concat(bookshelfCandidates);
                    console.log(`generateRecommendations: Bookshelf candidates found: ${bookshelfCandidates.length}`);

                    // Get lightweight AI-powered candidates
                    const aiCandidates = await getAIPoweredRecommendations();
                    allLightweightCandidates = allLightweightCandidates.concat(aiCandidates);
                    console.log(`generateRecommendations: AI candidates found: ${aiCandidates.length}`);

                    // Get lightweight trending candidates
                    const trendingCandidates = await getTrendingOpenLibraryCandidates(OPEN_LIBRARY_LIGHTWEIGHT_LIMIT);
                    allLightweightCandidates = allLightweightCandidates.concat(trendingCandidates);
                    console.log(`generateRecommendations: Trending candidates found: ${trendingCandidates.length}`);


                    // Deduplicate lightweight candidates by workKey
                    const uniqueLightweightCandidates = [];
                    const seenLightweightWorkKeys = new Set();
                    for (const candidate of allLightweightCandidates) {
                        if (candidate.workKey && !seenLightweightWorkKeys.has(candidate.workKey)) {
                            uniqueLightweightCandidates.push(candidate);
                            seenLightweightWorkKeys.add(candidate.workKey);
                        }
                    }
                    allLightweightCandidates = uniqueLightweightCandidates;
                    console.log(`generateRecommendations: Attempt ${attempt + 1}, collected ${allLightweightCandidates.length} unique lightweight candidates.`);


                    if (allLightweightCandidates.length >= TARGET_BOOKS * 5) { // Collect a larger buffer for stricter filtering
                        console.log("generateRecommendations: Enough lightweight candidates collected, breaking fetch loop.");
                        break;
                    }
                }

                // Shuffle all collected lightweight candidates for random selection
                for (let i = allLightweightCandidates.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allLightweightCandidates[i], allLightweightCandidates[j]] = [allLightweightCandidates[j], allLightweightCandidates[i]];
                }
                console.log("generateRecommendations: All lightweight candidates shuffled.");

                // Phase 2: Fetch full details and apply scoring/filters until TARGET_BOOKS are found
                let finalRecommendations = [];
                let currentCandidateIndex = 0;
                const selectedAuthorsInCurrentBatch = new Set(); // To track authors for deprioritization within the current batch

                while (finalRecommendations.length < TARGET_BOOKS && currentCandidateIndex < allLightweightCandidates.length) {
                    const batchToProcess = allLightweightCandidates.slice(currentCandidateIndex, currentCandidateIndex + FULL_DETAIL_FETCH_BATCH_SIZE);
                    currentCandidateIndex += FULL_DETAIL_FETCH_BATCH_SIZE;
                    console.log(`generateRecommendations: Processing batch of ${batchToProcess.length} candidates, starting from index ${currentCandidateIndex - FULL_DETAIL_FETCH_BATCH_SIZE}.`);


                    for (const lightweightBook of batchToProcess) {
                        if (finalRecommendations.length >= TARGET_BOOKS) {
                            console.log("generateRecommendations: Target number of recommendations reached, stopping batch processing.");
                            break;
                        }

                        if (processedWorkKeys.has(lightweightBook.workKey)) {
                            console.log(`generateRecommendations: Skipping ${lightweightBook.title} (workKey: ${lightweightBook.workKey}) - already processed.`);
                            continue;
                        }

                        const fullBookDetails = await fetchBookDetailsFromOpenLibrary(lightweightBook.workKey);
                        processedWorkKeys.add(lightweightBook.workKey); // Mark as processed regardless of success

                        if (fullBookDetails) { // fullBookDetails will be null if it failed any internal filters (cover, year)
                            if (existingBookWorkKeys.has(fullBookDetails.workKey)) {
                                console.log(`generateRecommendations: Skipping ${fullBookDetails.title} (workKey: ${fullBookDetails.workKey}) - already exists in a list.`);
                                continue;
                            }

                            // Apply scoring here to decide if it's worth adding, considering author diversity
                            const lovedBooks = window.bookShelfBooks.filter(book => book.userRating === 'love');
                            const likedBooks = window.bookShelfBooks.filter(book => book.userRating === 'like');
                            const score = calculateBookScore(fullBookDetails, lovedBooks, likedBooks, selectedAuthorsInCurrentBatch);
                            console.log(`generateRecommendations: Scored "${fullBookDetails.title}" (workKey: ${fullBookDetails.workKey}) with score: ${score}`);

                            // Only add if score is high enough (after deprioritization)
                            if (score >= MIN_SCORE_THRESHOLD) {
                                // Call LLM to get pros, cons, summary
                                const evaluation = await getAIProsConsSummary(fullBookDetails);
                                finalRecommendations.push({
                                    ...fullBookDetails,
                                    score: score,
                                    pros: evaluation.pros,
                                    cons: evaluation.cons,
                                    summary: evaluation.summary // Store summary as well
                                });
                                selectedAuthorsInCurrentBatch.add(fullBookDetails.author.toLowerCase());
                                console.log(`generateRecommendations: Added "${fullBookDetails.title}" to final recommendations (current count: ${finalRecommendations.length}).`);
                            } else {
                                console.log(`generateRecommendations: Skipping "${fullBookDetails.title}" - score ${score} below threshold ${MIN_SCORE_THRESHOLD}.`);
                            }
                        } else {
                            console.log(`generateRecommendations: Skipping lightweight book (workKey: ${lightweightBook.workKey}) - fetchBookDetailsFromOpenLibrary returned null.`);
                        }
                    }
                }

                // Sort recommendations by score in descending order
                finalRecommendations.sort((a, b) => b.score - a.score);
                console.log("generateRecommendations: Final recommendations sorted by score:", finalRecommendations);

                if (loader) loader.style.display = 'none';

                if (finalRecommendations.length > 0) {
                    let autoApprovedCount = 0;
                    let pendingApprovalCount = 0;

                    for (const book of finalRecommendations.slice(0, TARGET_BOOKS)) {
                        // Check against current recommended list before adding to avoid duplicates that might have been added by another admin session
                        const isDuplicateInRecommended = window.recommendedBooks.some(b => b.workKey === book.workKey);
                        console.log(`generateRecommendations: Processing "${book.title}" (workKey: ${book.workKey}). Is duplicate in recommended: ${isDuplicateInRecommended}`);

                        if (!isDuplicateInRecommended) {
                            if (book.score >= AUTO_APPROVE_SCORE_THRESHOLD) {
                                // Auto-approve: add directly to recommended_books
                                await setBookInFirestore(book, 'recommended_books');
                                autoApprovedCount++;
                                console.log(`generateRecommendations: Auto-approved "${book.title}" (score: ${book.score}).`);
                            } else {
                                // Requires admin approval: add to admin_pending_recs
                                await setBookInFirestore(book, 'admin_pending_recs', window.adminUserId);
                                pendingApprovalCount++;
                                console.log(`generateRecommendations: "${book.title}" (score: ${book.score}) added to pending for approval.`);
                            }
                        } else {
                            console.log(`generateRecommendations: Skipping "${book.title}" - already in recommended_books (duplicate check).`);
                        }
                    }

                    let messageText = '';
                    if (autoApprovedCount > 0) {
                        messageText += `${autoApprovedCount} new high-scoring recommendations automatically added to Beth's list! `;
                    }
                    if (pendingApprovalCount > 0) {
                        messageText += `${pendingApprovalCount} new recommendations awaiting your approval in the Admin Panel.`;
                    }
                    if (messageText === '') {
                        messageText = 'No new recommendations found at this time based on Beth\'s preferences and score threshold. Try rating more books or adjusting preferences.';
                    }
                    showMessage(messageText, false, false);

                } else {
                    showMessage('No new recommendations found at this time based on Beth\'s preferences and score threshold. Try rating more books or adjusting preferences.', false, false);
                }
            }
            catch (error) {
                console.error('ERROR: Error during recommendation generation:', error);
                if (loader) loader.style.display = 'none';
                showMessage('Failed to generate recommendations. Please try again later.', false, false);
            }
        }

        /**
         * Generates lightweight book candidates based on books Beth has loved or liked.
         * Queries Open Library using authors and subjects from Beth's bookshelf.
         * @param {number} limit - The number of results to request per query.
         * @returns {Promise<Array<Object>>} A promise that resolves to an array of lightweight book candidate objects.
         */
        async function getBookshelfBasedRecommendations(limit = 30) {
            // Use window.bookShelfBooks which is updated by Firestore listener
            const lovedBooks = window.bookShelfBooks.filter(book => book.userRating === 'love');
            const likedBooks = window.bookShelfBooks.filter(book => book.userRating === 'like');

            if (lovedBooks.length === 0 && likedBooks.length === 0) {
                console.log("getBookshelfBasedRecommendations: No loved or liked books to base recommendations on.");
                return [];
            }

            let lightweightCandidates = [];
            let queries = new Set();

            // Generate queries for authors and subjects from loved/liked books
            lovedBooks.concat(likedBooks).forEach(book => {
                if (book.author) {
                    queries.add(book.author.split(',')[0].trim()); // Use first author
                }
                if (book.subjects && Array.isArray(book.subjects)) {
                    book.subjects.slice(0, 2).forEach(subject => { // Use top 2 subjects
                        queries.add(subject.trim());
                    });
                }
            });

            // Fallback to general genre keywords if no specific bookshelf queries are generated
            if (queries.size === 0) {
                BETH_GENRE_KEYWORDS.forEach(genre => queries.add(genre));
                console.log("getBookshelfBasedRecommendations: Falling back to general genre keywords for queries.");
            } else {
                console.log("getBookshelfBasedRecommendations: Generated queries from bookshelf:", Array.from(queries));
            }


            for (const q of Array.from(queries)) {
                const fullQuery = `${q} AND language:eng`;
                try {
                    const response = await fetch(`${OPEN_LIBRARY_SEARCH_URL}${encodeURIComponent(fullQuery)}&limit=${limit}`);
                    if (!response.ok) {
                        console.warn(`WARNING: Open Library sub-query failed for "${fullQuery}": ${response.status}`);
                        continue;
                    }
                    const data = await response.json();

                    if (data.docs && data.docs.length > 0) {
                        for (const doc of data.docs) {
                            const workKeyMatch = doc.key ? doc.key.match(/\/works\/(OL\d+W)/) : null;
                            const firstPublishYear = doc.first_publish_year && typeof doc.first_publish_year === 'number' ? doc.first_publish_year : null;

                            // Only add if it has a key, author, cover, valid workKey, and meets min publish year
                            if (doc.key && (doc.author_name || doc.author) && doc.cover_i && workKeyMatch && workKeyMatch[1] &&
                                (firstPublishYear && firstPublishYear >= MIN_PUBLISH_YEAR)) { // Use cleaned firstPublishYear
                                lightweightCandidates.push({
                                    title: doc.title || 'Unknown Title',
                                    author: doc.author_name ? doc.author_name.join(', ') : (doc.author || 'Unknown Author'),
                                    description: doc.first_sentence ? doc.first_sentence[0] : '',
                                    imageUrl: doc.cover_i ? `${OPEN_LIBRARY_COVER_URL}${doc.cover_i}-M.jpg` : 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover',
                                    goodreadsUrl: doc.key ? `https://openlibrary.org${doc.key}` : '#',
                                    rating: doc.ratings_average && typeof doc.ratings_average === 'number' ? doc.ratings_average : null,
                                    subjects: doc.subject || [],
                                    workKey: workKeyMatch[1],
                                    source: 'Based on Bookshelf (Open Library - Lightweight)',
                                    first_publish_year: firstPublishYear // Use cleaned firstPublishYear
                                });
                            } else {
                                console.log(`DEBUG: Skipping bookshelf-based candidate "${doc.title}" (workKey: ${doc.key}) - missing essential data, cover, or too old for initial consideration.`);
                            }
                        }
                    }
                }
                catch (error) {
                    console.error(`ERROR: Error fetching Open Library sub-query for "${fullQuery}":`, error);
                }
            }
            console.log("getBookshelfBasedRecommendations: Found", lightweightCandidates.length, "candidates.");
            return lightweightCandidates;
        }

        /**
         * Generates AI-powered book recommendations by prompting a language model.
         * The AI considers Beth's preferences and negative feedback.
         * Fetches corresponding Open Library details for the AI-suggested books.
         * @returns {Promise<Array<Object>>} A promise that resolves to an array of lightweight book candidate objects from AI.
         */
        async function getAIPoweredRecommendations() {
            // Use window.bookShelfBooks and getNegativeFeedbackFromFirestore
            const lovedBooks = window.bookShelfBooks.filter(book => book.userRating === 'love');
            const likedBooks = window.bookShelfBooks.filter(book => book.userRating === 'like');
            const negativeFeedbackTerms = await getNegativeFeedbackFromFirestore(); // Fetch from Firestore

            let prompt = `You are a book recommendation engine for a person named Beth.
            Beth enjoys the following genres: ${BETH_GENRE_KEYWORDS.join(', ')}.`;

            if (lovedBooks.length > 0) {
                prompt += `\nShe has LOVED these books: ${lovedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
            }
            if (likedBooks.length > 0) {
                prompt += `\nShe has LIKED these books: ${likedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
            }

            prompt += `\nBased on these preferences, please provide 5-10 new book titles and their authors that Beth might enjoy.
            **Crucially, prioritize recommending books by authors she has NOT read yet, but whose writing style, thematic elements, or overall vibe are similar to the authors she has loved or liked.** Focus on books that are currently popular or widely discussed in online book communities, reflecting current trends in her preferred genres.
            Also, pay attention to the writing style: recommend writers that use similar writing styles to the books Beth loves and likes, and explicitly shy away from stiffer written books by writers like Agatha Christie.
            IMPORTANT: Do NOT recommend books related to occult, demonism, spiritism, witchcraft, or any general fantasy/magic themes.
            IMPORTANT: Also, strictly avoid self-help, how-to guides, manuals, and romance novels.`;

            // Add dynamic negative feedback from user
            if (negativeFeedbackTerms.length > 0) {
                prompt += `\nIMPORTANT: Based on previous feedback, also strictly avoid books with these themes or genres: ${negativeFeedbackTerms.join(', ')}.`;
            }

            // Added flexibility instruction
            prompt += `\nProvide your recommendations as a JSON array of objects, each with a "title" and "author" property.
            Example: [{"title": "Book Title One", "author": "Author Name One"}, {"title": "Book Title Two", "author": "Author Name Two"}].
            If you cannot find specific books that perfectly match all criteria, please still provide a few general recommendations in the requested JSON format.`;

            let aiLightweightCandidates = [];

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    "title": { "type": "STRING" },
                                    "author": { "type": "STRING" }
                                },
                                "propertyOrdering": ["title", "author"]
                            }
                        }
                    }
                };
                // Use the provided API key or fallback to empty string for Canvas
                const apiKey = "AIzaSyCU2J_0zErEIPLl-3ejBABDM-NYKOg44Zk" || "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                console.log("DEBUG: Sending prompt to Gemini API for AI recommendations:", prompt); // Log the prompt
                console.log("DEBUG: Sending payload to Gemini API for AI recommendations:", payload); // Log the payload

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                let result;
                let rawResponseText = '';

                try {
                    rawResponseText = await response.text();
                    console.log("DEBUG: Raw LLM AI Recommendations Response Text:", rawResponseText); // Log raw response
                    if (!rawResponseText || rawResponseText.trim() === '') {
                        throw new Error("Empty or whitespace response from Gemini API.");
                    }
                    result = JSON.parse(rawResponseText);
                }
                catch (jsonError) {
                    console.error(`ERROR: Failed to parse Gemini API response as JSON:`, jsonError, `Raw response text:`, rawResponseText);
                    showMessage('Failed to get AI recommendations due to an invalid API response. Please try again.', false, false);
                    return [];
                }

                if (!response.ok) {
                    console.error(`ERROR: Gemini API responded with status ${response.status}:`, result);
                    let errorMessage = `Failed to get AI recommendations. API error: ${response.status}.`;
                    if (response.status === 400) {
                        errorMessage += ` This might be due to an overly restrictive prompt or a content policy violation. Check the console for more details.`;
                    }
                    showMessage(errorMessage, false, false);
                    return [];
                }

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;

                    if (!jsonString || jsonString.trim() === '') {
                        console.error('ERROR: Gemini API returned empty or whitespace JSON string for recommendations.');
                        showMessage('AI recommendations could not be generated (empty response). Please try again.', false, false);
                        return [];
                    }

                    try {
                        const parsedRecommendations = JSON.parse(jsonString);
                        console.log("DEBUG: Parsed AI recommendations:", parsedRecommendations);

                        for (const rec of parsedRecommendations) {
                            const query = `${rec.title} ${rec.author}`;
                            const olResponse = await fetch(`${OPEN_LIBRARY_SEARCH_URL}${encodeURIComponent(query)}&limit=1`); // Limit to 1 best match
                            if (!olResponse.ok) {
                                console.warn(`WARNING: Open Library search failed for AI book "${query}": ${olResponse.status}`);
                                continue;
                            }
                            const olData = await olResponse.json();

                            if (olData.docs && olData.docs.length > 0) {
                                const doc = olData.docs[0];
                                const workKeyMatch = doc.key ? doc.key.match(/\/works\/(OL\d+W)/) : null;
                                const firstPublishYear = doc.first_publish_year && typeof doc.first_publish_year === 'number' ? doc.first_publish_year : null;

                                // Only add if it has a key, author, cover, valid workKey, and meets min publish year
                                if (doc.key && (doc.author_name || doc.author) && doc.cover_i && workKeyMatch && workKeyMatch[1] &&
                                    (firstPublishYear && firstPublishYear >= MIN_PUBLISH_YEAR)) { // Use cleaned firstPublishYear
                                    aiLightweightCandidates.push({
                                        title: doc.title || 'Unknown Title',
                                        author: doc.author_name ? doc.author_name.join(', ') : (doc.author || rec.author),
                                        description: doc.first_sentence ? doc.first_sentence[0] : '',
                                        imageUrl: doc.cover_i ? `${OPEN_LIBRARY_COVER_URL}${doc.cover_i}-M.jpg` : 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover',
                                        goodreadsUrl: doc.key ? `https://openlibrary.org${doc.key}` : '#',
                                        rating: doc.ratings_average && typeof doc.ratings_average === 'number' ? doc.ratings_average : null,
                                        subjects: doc.subject || [],
                                        workKey: workKeyMatch[1],
                                        source: 'AI Recommendation (Lightweight)',
                                        first_publish_year: firstPublishYear // Use cleaned firstPublishYear
                                    });
                                } else {
                                    console.log(`DEBUG: Skipping AI-suggested book "${doc.title}" (workKey: ${doc.key}) - missing essential data, cover, or too old for initial consideration.`);
                                }
                            } else {
                                console.log(`DEBUG: No Open Library match found for AI-suggested book: "${query}"`);
                            }
                        }

                    }
                    catch (parseError) {
                        console.error('ERROR: Failed to parse AI recommendations JSON from LLM response:', parseError, 'Raw JSON string:', jsonString);
                        showMessage('AI recommendations could not be parsed. Please try again.', false, false);
                    }
                } else {
                    console.error("ERROR: AI response structure unexpected or no candidates:", result);
                    showMessage('Could not generate AI recommendations. Please try again.', false, false);
                }

            }
            catch (error) {
                console.error('ERROR: Error calling Gemini API for insight (network/fetch issue):', error);
                showMessage('Failed to get AI recommendations. Please check your network connection or API key.', false, false);
            }
            console.log("getAIPoweredRecommendations: Found", aiLightweightCandidates.length, "candidates.");
            return aiLightweightCandidates;
        }

        /**
         * Deduplicates a list of books and filters out any books that already exist
         * in the main recommended, bookshelf, flagged, Beth's deleted, or admin pending lists.
         * @param {Array<Object>} booksArray - The array of book objects to deduplicate and filter.
         * @returns {Array<Object>} A new array containing only unique and non-existing books.
         */
        function deduplicateAndFilterExistingBooks(booksArray) {
            const seenWorkKeys = new Set();
            const uniqueBooks = [];
            // Collect all existing book workKeys (case-insensitive) from all relevant storage areas
            const existingBookWorkKeys = new Set(window.recommendedBooks.map(book => book.workKey));
            window.bookShelfBooks.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.flaggedBooks.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.bethDeletedBooks.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.adminPendingRecommendations.forEach(book => existingBookWorkKeys.add(book.workKey));
            window.adminApprovedBooks.forEach(book => existingBookWorkKeys.add(book.workKey)); // NEW: Include admin approved books

            for (const book of booksArray) {
                // Ensure book.workKey exists before using it
                if (!book.workKey) {
                    console.warn("Skipping book due to missing workKey:", book);
                    continue;
                }
                // Only add if not already seen in this batch and not an existing book in any other list
                if (!seenWorkKeys.has(book.workKey) && !existingBookWorkKeys.has(book.workKey)) {
                    seenWorkKeys.add(book.workKey);
                    uniqueBooks.push(book);
                } else {
                    if (seenWorkKeys.has(book.workKey)) {
                        console.log(`DEBUG: Deduplicating "${book.title}" - already seen in this batch.`);
                    }
                    if (existingBookWorkKeys.has(book.workKey)) {
                        console.log(`DEBUG: Filtering out "${book.title}" - already in recommended/bookshelf/flagged/Beth's deleted/pending/approved.`);
                    }
                }
            }
            return uniqueBooks;
        }

        /**
         * Fetches a personalized insight from the LLM about why a specific book is recommended for Beth.
         * Displays the insight in a message box.
         * @param {Event} event - The click event from the "Why for Me?" button.
         */
        async function getPersonalizedInsight(event) {
            showMessage('Generating personalized insight... This might take a moment.', true, false);

            const button = event.currentTarget;
            const book = JSON.parse(button.dataset.bookJson);

            const { title, author, description, subjects } = book;

            const favoriteGenres = BETH_GENRE_KEYWORDS.join(', ');
            // Use window.bookShelfBooks which is updated by Firestore listener
            const lovedBooks = window.bookShelfBooks.filter(b => b.userRating === 'love').map(b => b.title);
            const likedBooks = window.bookShelfBooks.filter(b => b.userRating === 'like').map(b => b.title);

            let prompt = `You are an AI assistant helping Beth understand why a specific book is recommended for her.
            Speak directly to Beth.`;
            prompt += `\nYour favorite genres are: ${favoriteGenres}.`;
            if (lovedBooks.length > 0) {
                prompt += `\nYou have "loved" the following books: ${lovedBooks.join(', ')}.`;
            }
            if (likedBooks.length > 0) {
                prompt += `\nYou have "liked" the following books: ${likedBooks.join(', ')}.`;
            }
            prompt += `\nHere is the book in question:\n`;
            prompt += `Title: "${title}"\n`;
            prompt += `Author: ${author}\n`;
            if (description && description !== '') {
                prompt += `Description: ${description}\n`;
            }
            if (subjects && subjects.length > 0) {
                prompt += `Subjects/Themes: ${subjects.join(', ')}\n`;
            }
            // Explicit instruction to only provide the explanation and strip any leading conversational text
            prompt += `\nExplain in a friendly, concise, and compelling way why this book is a good recommendation for you, connecting it to your stated preferences and past liked/loved books. Focus on aspects like genre, themes, author style (if applicable), and overall appeal for someone with your tastes. Keep it to 2-3 sentences. Your response MUST ONLY be the explanation itself, starting directly with the reason, and contain no introductory phrases, conversational filler, or repetition of the book title/your role.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                // Use the provided API key or fallback to empty string for Canvas
                const apiKey = "AIzaSyCU2J_0zErEIPLl-3ejBABDM-NYKOg44Zk" || "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                let insightResult;
                try {
                    insightResult = await response.json();
                }
                catch (jsonError) {
                    const errorText = await response.text();
                    console.error(`ERROR: Failed to parse LLM insight response as JSON:`, jsonError, `Raw response text:`, errorText);
                    showMessage('Could not generate insight due to an invalid API response. Please try again.', false, false);
                    return;
                }

                if (!response.ok) {
                    console.error(`ERROR: LLM insight API responded with status ${response.status}:`, insightResult);
                    showMessage(`Could not generate insight. API error: ${response.status}.`, false, false);
                    return;
                }

                if (insightResult.candidates && insightResult.candidates.length > 0 &&
                    insightResult.candidates[0].content && insightResult.candidates[0].content.parts &&
                    insightResult.candidates[0].content.parts.length > 0) {
                    let insightText = insightResult.candidates[0].content.parts[0].text;
                    // Post-process to remove any lingering conversational intros
                    insightText = insightText.replace(/^(Sure, here's why this book is a good recommendation for Beth:|Here's why this book is a good recommendation for Beth:|This book is a good recommendation for Beth because|This book is recommended for Beth because|Here's why this book is recommended for Beth:)\s*/i, '');
                    insightText = insightText.replace(new RegExp(`^\\*\\*Why "${title}" for Beth\\?\\*\\*\\n\\n`, 'i'), '');
                    insightText = insightText.replace(/^(This book is recommended for you because|You might enjoy this book because|This book aligns with your preferences because|This book is a great fit for you because)\s*/i, '');

                    showMessage(`${insightText}`, false, true);
                } else {
                    console.error("ERROR: LLM response structure unexpected or no candidates:", insightResult);
                    showMessage('Could not generate insight. Please try again.', false, false);
                }

            }
            catch (error) {
                console.error('ERROR: Error calling Gemini API for insight (network/fetch issue):', error);
                showMessage('Failed to get personalized insight. Please check your network connection or API key.', false, false);
            }
        }

        /**
         * Evaluates a book for Beth using AI, providing pros, cons, and a summary.
         * Displays the evaluation in a message box and offers an option to add to recommendations.
         */
        async function evaluateBookForBeth() {
            const urlInput = document.getElementById('evaluate-book-url-input');
            const url = urlInput.value.trim();
            const loader = document.getElementById('search-loader');
            const message = document.getElementById('search-message');

            if (message) message.classList.add('hidden');
            if (loader) loader.style.display = 'block';
            showMessage('Evaluating book for Beth... This might take a moment.', true, false);

            const workKeyMatch = url.match(/\/works\/(OL\d+W)/);
            if (!workKeyMatch || !workKeyMatch[1]) {
                if (loader) loader.style.display = 'none';
                showMessage('Invalid Open Library Work URL. Please provide a URL like https://openlibrary.org/works/OL12345W', false, false);
                return;
            }

            const workKey = workKeyMatch[1];

            try {
                const bookDetails = await fetchBookDetailsFromOpenLibrary(workKey);

                if (!bookDetails) {
                    if (loader) loader.style.display = 'none';
                    showMessage('Failed to retrieve book details from the provided Open Library URL. Please check the URL and try again.', false, false);
                    return;
                }

                const { title, author } = bookDetails;

                // Use window.bookShelfBooks which is updated by Firestore listener
                const lovedBooks = window.bookShelfBooks.filter(b => b.userRating === 'love');
                const likedBooks = window.bookShelfBooks.filter(b => b.userRating === 'like');

                // Calculate the score using the shared scoring function
                const internalScore = calculateBookScore(bookDetails, lovedBooks, likedBooks, new Set());

                // Use the new helper function to get evaluation
                const evaluation = await getAIProsConsSummary(bookDetails);

                let evaluationHtml = `
                    <h3 class="text-xl font-bold mb-2">Evaluation for "${escapeHtmlAttribute(title)}" by ${escapeHtmlAttribute(author)}</h3>
                    <p class="text-lg font-semibold mb-4">Internal Score: <span class="text-emerald-600">${internalScore}/100</span></p>
                    <p class="mb-4">${escapeHtmlAttribute(evaluation.summary)}</p>
                    <div class="mb-4">
                        <h4 class="font-semibold text-green-700">Pros:</h4>
                        <ul class="list-disc list-inside text-left">
                            ${evaluation.pros.map(p => `<li>${escapeHtmlAttribute(p)}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="mb-4">
                        <h4 class="font-semibold text-red-700">Cons:</h4>
                        <ul class="list-disc list-inside text-left">
                            ${evaluation.cons.map(c => `<li>${escapeHtmlAttribute(c)}</li>`).join('')}
                        </ul>
                    </div>
                    <button id="add-evaluated-book-button" class="action-button mt-4 px-6 py-3 bg-emerald-600 hover:bg-emerald-700">Add to Recommended Reads</button>
                `;

                showMessage(evaluationHtml, false, true); // Show as LLM insight

                // Attach event listener to the "Add to Recommended Reads" button
                const addEvaluatedBookButton = document.getElementById('add-evaluated-book-button');
                if (addEvaluatedBookButton) {
                    addEvaluatedBookButton.addEventListener('click', () => {
                        // Create a synthetic event object for addBookToCuratedList
                        const syntheticEvent = {
                            currentTarget: {
                                dataset: {
                                    bookJson: JSON.stringify(bookDetails) // Use the original bookDetails
                                }
                            }
                        };
                        addBookToCuratedList(syntheticEvent);
                        const messageBox = document.getElementById('message-box');
                        if (messageBox) {
                            messageBox.style.display = 'none'; // Close evaluation message
                            messageBox.classList.remove('llm-insight');
                        }
                        if (urlInput) urlInput.value = ''; // Clear input
                    }, { once: true }); // Use { once: true } to prevent multiple listeners
                }


            }
            catch (error) {
                console.error('ERROR: Error during book evaluation:', error);
                showMessage('Failed to evaluate book. Please try again later.', false, false);
            }
            finally {
                if (loader) loader.style.display = 'none';
            }
        }


        /**
         * Controls the visibility of admin-specific UI elements.
         * This function is called during `initializeAppContent` based on the login PIN.
         * @param {boolean} showAdmin - True to show admin elements, false to hide them.
         */
        function setAdminUIVisibility(showAdmin) {
            const adminPanel = document.getElementById('admin-search-panel');
            const navFlaggedBooks = document.getElementById('nav-flagged-books');
            const navAdminApprovedBooks = document.getElementById('nav-admin-approved-books');

            if (adminPanel) adminPanel.classList.toggle('hidden', !showAdmin);
            if (navFlaggedBooks) navFlaggedBooks.classList.toggle('hidden', !showAdmin);
            if (navAdminApprovedBooks) navAdminApprovedBooks.classList.toggle('hidden', !showAdmin);

            console.log(`setAdminUIVisibility: Admin panel and navigation set to ${showAdmin ? 'visible' : 'hidden'}.`);

            // Clear search results and message when admin panel visibility changes
            const searchResults = document.getElementById('search-results');
            const searchInput = document.getElementById('search-input');
            const manualAddUrlInput = document.getElementById('manual-add-url-input');
            const evaluateBookUrlInput = document.getElementById('evaluate-book-url-input');
            const searchMessage = document.getElementById('search-message');

            if (searchResults) searchResults.innerHTML = '';
            if (searchInput) searchInput.value = '';
            if (manualAddUrlInput) manualAddUrlInput.value = '';
            if (evaluateBookUrlInput) evaluateBookUrlInput.value = '';
            if (searchMessage) searchMessage.classList.add('hidden');

            // Re-render relevant sections
            displayRecommendedBooks(); // This will re-render and correctly show/hide admin actions on book cards
            if (showAdmin) {
                displayAdminAlerts();
                displayAdminPendingRecommendations();
                displayAdminApprovedBooks();
            }
        }


        /**
         * Displays AI-generated recommendations that are awaiting admin approval.
         * Includes options to approve, remove, or red flag these books.
         */
        function displayAdminPendingRecommendations() {
            // Data is now sourced from window.adminPendingRecommendations
            const pendingRecsContainer = document.getElementById('admin-pending-recs-container');
            const pendingRecsList = document.getElementById('admin-pending-recs-list');
            const noPendingRecsMessage = document.getElementById('no-admin-pending-recs-message');

            // Add null checks for robustness
            if (!pendingRecsContainer) {
                console.error("ERROR: 'admin-pending-recs-container' element not found. Please check its ID in the HTML.");
                return;
            }
            if (!pendingRecsList) {
                console.error("ERROR: 'admin-pending-recs-list' element not found. Please check its ID in the HTML.");
                return;
            }
            if (!noPendingRecsMessage) {
                console.error("ERROR: 'no-admin-pending-recs-message' element not found. Please check its ID in the HTML.");
                return;
            }

            console.log("displayAdminPendingRecommendations: Called. Pending recs:", window.adminPendingRecommendations.length);

            pendingRecsList.innerHTML = ''; // Clear existing content

            if (window.adminPendingRecommendations.length === 0) {
                pendingRecsContainer.classList.add('hidden');
                noPendingRecsMessage.classList.remove('hidden');
            } else {
                pendingRecsContainer.classList.remove('hidden');
                noPendingRecsMessage.classList.add('hidden');
                window.adminPendingRecommendations.forEach(book => {
                    const pendingItem = document.createElement('div');
                    pendingItem.className = 'admin-pending-rec-item';

                    const descriptionHtml = book.description ? `<p class="text-gray-700 text-sm mt-2 mb-2">${escapeHtmlAttribute(book.description)}</p>` : '';
                    const prosHtml = book.pros && book.pros.length > 0 ? `
                        <h4 class="font-semibold text-green-700 mt-2">Pros:</h4>
                        <ul class="list-disc list-inside text-left text-sm">
                            ${book.pros.map(p => `<li>${escapeHtmlAttribute(p)}</li>`).join('')}
                        </ul>
                    ` : '';
                    const consHtml = book.cons && book.cons.length > 0 ? `
                        <h4 class="font-semibold text-red-700 mt-2">Cons:</h4>
                        <ul class="list-disc list-inside text-left text-sm">
                            ${book.cons.map(c => `<li>${escapeHtmlAttribute(c)}</li>`).join('')}
                        </ul>
                    ` : '';
                    const openLibraryLinkHtml = book.goodreadsUrl ? `
                        <a href="${escapeJsStringForHtmlAttribute(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline text-sm mt-2 block">View on Open Library</a>
                    ` : '';
                    const publishYearHtml = book.first_publish_year !== null ? `<p class="text-gray-600 text-xs mt-1">Published: ${escapeHtmlAttribute(book.first_publish_year)}</p>` : '';


                    pendingItem.innerHTML = `
                        <div class="book-info">
                            "${escapeHtmlAttribute(book.title)}" by ${escapeHtmlAttribute(book.author)} (Score: ${book.score}/100)
                            ${publishYearHtml}
                        </div>
                        ${descriptionHtml}
                        ${prosHtml}
                        ${consHtml}
                        ${openLibraryLinkHtml}
                        <div class="flex gap-2 mt-4">
                            <button class="approve-button approve-for-beth-btn" data-book-json="${escapeHtmlAttribute(JSON.stringify(book))}">Approve for Beth</button>
                            <button class="action-button pass-btn skip-pending-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Skip</button>
                            <button class="action-button red-flag-btn red-flag-pending-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}" data-author="${escapeJsStringForHtmlAttribute(book.author)}">ðŸš© Red Flag</button>
                        </div>
                    `;
                    pendingRecsList.appendChild(pendingItem);
                });

                // Attach event listeners to the newly created buttons
                pendingRecsList.querySelectorAll('.approve-for-beth-btn').forEach(button => {
                    button.addEventListener('click', approveBookForBeth);
                });
                pendingRecsList.querySelectorAll('.skip-pending-btn').forEach(button => {
                    button.addEventListener('click', (event) => skipPendingBook(event.currentTarget.dataset.workkey));
                });
                pendingRecsList.querySelectorAll('.red-flag-pending-btn').forEach(button => {
                    button.addEventListener('click', (event) => redFlagBookFromPending(event.currentTarget.dataset.workkey, event.currentTarget.dataset.author));
                });
            }
        }

        /**
         * Displays books that have been approved by the admin but not yet moved to Beth's recommendations.
         */
        function displayAdminApprovedBooks() {
            // Data is now sourced from window.adminApprovedBooks
            const approvedBooksList = document.getElementById('admin-approved-books-list');
            const noApprovedBooksMessage = document.getElementById('no-admin-approved-books-message');

            // Add more specific null checks for debugging
            if (!approvedBooksList) {
                console.error("ERROR: 'admin-approved-books-list' element not found. Please check its ID in the HTML.");
                return;
            }
            if (!noApprovedBooksMessage) {
                console.error("ERROR: 'no-admin-approved-books-message' element not found. Please check its ID in the HTML.");
                return;
            }

            console.log("displayAdminApprovedBooks: Called. Approved books:", window.adminApprovedBooks.length);

            approvedBooksList.innerHTML = ''; // Clear existing content

            if (window.adminApprovedBooks.length === 0) {
                noApprovedBooksMessage.classList.remove('hidden');
            } else {
                noApprovedBooksMessage.classList.add('hidden');
                window.adminApprovedBooks.forEach(book => {
                    const approvedItem = document.createElement('div');
                    approvedItem.className = 'admin-approved-book-item';

                    const descriptionHtml = book.description ? `<p class="text-gray-700 text-sm mt-2 mb-2">${escapeHtmlAttribute(book.description)}</p>` : '';
                    const prosHtml = book.pros && book.pros.length > 0 ? `
                        <h4 class="font-semibold text-green-700 mt-2">Pros:</h4>
                        <ul class="list-disc list-inside text-left text-sm">
                            ${book.pros.map(p => `<li>${escapeHtmlAttribute(p)}</li>`).join('')}
                        </ul>
                    ` : '';
                    const consHtml = book.cons && book.cons.length > 0 ? `
                        <h4 class="font-semibold text-red-700 mt-2">Cons:</h4>
                        <ul class="list-disc list-inside text-left text-sm">
                            ${book.cons.map(c => `<li>${escapeHtmlAttribute(c)}</li>`).join('')}
                        </ul>
                    ` : '';
                    const openLibraryLinkHtml = book.goodreadsUrl ? `
                        <a href="${escapeJsStringForHtmlAttribute(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline text-sm mt-2 block">View on Open Library</a>
                    ` : '';
                    const publishYearHtml = book.first_publish_year !== null ? `<p class="text-gray-600 text-xs mt-1">Published: ${escapeHtmlAttribute(book.first_publish_year)}</p>` : '';


                    approvedItem.innerHTML = `
                        <div class="book-info">
                            "${escapeHtmlAttribute(book.title)}" by ${escapeHtmlAttribute(book.author)} (Score: ${book.score}/100)
                            ${publishYearHtml}
                        </div>
                        ${descriptionHtml}
                        ${prosHtml}
                        ${consHtml}
                        ${openLibraryLinkHtml}
                        <div class="flex gap-2 mt-4">
                            <button class="move-to-recs-button move-to-beths-recs-btn" data-book-json="${escapeHtmlAttribute(JSON.stringify(book))}">Move to Beth's Recommendations</button>
                            <button class="action-button red-flag-btn remove-from-approved-btn" data-workkey="${escapeJsStringForHtmlAttribute(book.workKey)}">Remove from Approved</button>
                        </div>
                    `;
                    approvedBooksList.appendChild(approvedItem);
                });

                // Attach event listeners to the newly created buttons
                approvedBooksList.querySelectorAll('.move-to-beths-recs-btn').forEach(button => {
                    button.addEventListener('click', moveToBethsRecommendations);
                });
                approvedBooksList.querySelectorAll('.remove-from-approved-btn').forEach(button => {
                    button.addEventListener('click', (event) => removeBookFromApproved(event.currentTarget.dataset.workkey));
                });
            }
        }

        /**
         * Approves a book from the pending recommendations list, moving it to the new admin approved list.
         * @param {Event} event - The click event from the "Approve for Beth" button.
         */
        async function approveBookForBeth(event) {
            const button = event.currentTarget;
            const bookToApprove = JSON.parse(button.dataset.bookJson);

            // Check for duplicate by workKey in adminApprovedBooks
            const isDuplicate = window.adminApprovedBooks.some(book => book.workKey === bookToApprove.workKey);

            if (!isDuplicate) {
                await setBookInFirestore(bookToApprove, 'admin_approved_books', window.adminUserId);
                showMessage(`"${bookToApprove.title}" has been approved and moved to Admin Approved Books!`, false, false);
            } else {
                showMessage(`"${bookToApprove.title}" is already in Admin Approved Books!`, false, false);
            }
            // Always remove from pending list after approval attempt (even if duplicate)
            await deleteBookFromFirestore(bookToApprove.workKey, 'admin_pending_recs', window.adminUserId);
        }

        /**
         * Moves an approved book from the Admin Approved list to Beth's Recommended Reads.
         * @param {Event} event - The click event from the "Move to Beth's Recommendations" button.
         */
        async function moveToBethsRecommendations(event) {
            const button = event.currentTarget;
            const bookToMove = JSON.parse(button.dataset.bookJson);

            // Check for duplicate in recommended books
            const isDuplicate = window.recommendedBooks.some(book => book.workKey === bookToMove.workKey);

            if (!isDuplicate) {
                bookToMove.userRating = null; // Reset user rating when moving to recommendations
                await setBookInFirestore(bookToMove, 'recommended_books');
                showMessage(`"${bookToMove.title}" has been moved to Beth's Recommended Reads!`, false, false);
            } else {
                showMessage(`"${bookToMove.title}" is already in Beth's Recommended Reads!`, false, false);
            }
            // Always remove from Admin Approved list after move attempt (even if duplicate)
            await deleteBookFromFirestore(bookToMove.workKey, 'admin_approved_books', window.adminUserId);
        }

        /**
         * Removes a book directly from the Admin Approved list.
         * @param {string} bookWorkKey - The workKey of the book to remove.
         */
        async function removeBookFromApproved(bookWorkKey) {
            const bookToRemove = window.adminApprovedBooks.find(book => book.workKey === bookWorkKey);
            if (bookToRemove) {
                await deleteBookFromFirestore(bookWorkKey, 'admin_approved_books', window.adminUserId);
                showMessage(`"${bookToRemove.title}" has been removed from Admin Approved Books.`, false, false);
            }
        }

        /**
         * Skips a book from the pending recommendations list without flagging it.
         * @param {string} bookWorkKey - The workKey of the book to skip.
         */
        async function skipPendingBook(bookWorkKey) {
            const bookToSkip = window.adminPendingRecommendations.find(book => book.workKey === bookWorkKey);
            if (bookToSkip) {
                await deleteBookFromFirestore(bookWorkKey, 'admin_pending_recs', window.adminUserId);
                showMessage(`"${bookToSkip.title}" has been skipped from pending recommendations.`, false, false);
            }
        }

        /**
         * Red flags a book directly from the pending recommendations list.
         * Prompts for a reason and adds it to Beth's negative feedback for AI learning.
         * @param {string} bookWorkKey - The workKey of the book to red flag.
         * @param {string} bookAuthor - The author of the book.
         */
        function redFlagBookFromPending(bookWorkKey, bookAuthor) {
            const bookToFlag = window.adminPendingRecommendations.find(book => book.workKey === bookWorkKey);
            if (!bookToFlag) return;

            const feedbackPrompt = `Why are you red-flagging "${bookToFlag.title}" by ${bookAuthor} from pending? (e.g., "romance", "magic", "self-help")`;

            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const closeButton = document.getElementById('message-box-close');

            messageText.innerHTML = `
                <p class="mb-4">${feedbackPrompt}</p>
                <input type="text" id="flag-reason-input" placeholder="Enter reason (e.g., 'romance', 'magic')"
                       class="w-full p-2 border border-gray-300 rounded-md mb-4 text-gray-700">
                <button id="submit-flag-reason" class="action-button px-4 py-2 bg-red-600 hover:bg-red-700">Submit Feedback</button>
                <button id="cancel-flag" class="mt-2 px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500">Cancel</button>
            `;
            messageBox.classList.remove('llm-insight');
            closeButton.style.display = 'none'; // Hide default close button

            messageBox.style.display = 'block';

            document.getElementById('submit-flag-reason').addEventListener('click', async () => {
                const reason = document.getElementById('flag-reason-input').value.trim();
                if (reason) {
                    await addNegativeFeedbackToFirestore(reason.toLowerCase());
                    showMessage(`Feedback received: "${reason}". AI will learn from this!`, false, false);
                } else {
                    showMessage('No feedback provided.', false, false);
                }
                messageBox.style.display = 'none'; // Hide the modal

                // Move the book to flagged books from pending
                await deleteBookFromFirestore(bookWorkKey, 'admin_pending_recs', window.adminUserId);
                bookToFlag.userRating = 'flagged'; // Mark as flagged
                bookToFlag.flaggedReason = reason || 'No reason provided'; // Store the reason
                await setBookInFirestore(bookToFlag, 'flagged_books', window.adminUserId);
            }, { once: true });

            document.getElementById('cancel-flag').addEventListener('click', () => {
                messageBox.style.display = 'none';
            }, { once: true });
        }


        // --- View Management ---
        /**
         * Controls which main view section is visible on the page.
         * Updates navigation button active states and refreshes content for the selected view.
         * @param {string} viewId - The ID of the view to show (e.g., 'recommendations-view').
         */
        function showView(viewId) {
            console.log(`showView: Attempting to show view: ${viewId}`);
            const views = ['recommendations-view', 'bookshelf-view', 'beth-deleted-books-view', 'flagged-books-view', 'admin-approved-books-view'];
            views.forEach(id => {
                const viewElement = document.getElementById(id);
                if (viewElement) {
                    if (id === viewId) {
                        viewElement.classList.remove('hidden');
                        console.log(`showView: Removed 'hidden' from ${id}`);
                    } else {
                        viewElement.classList.add('hidden');
                        console.log(`showView: Added 'hidden' to ${id}`);
                    }
                } else {
                    console.error(`ERROR: View element with ID '${id}' not found during showView.`);
                }
            });

            // Update active state for navigation buttons
            document.querySelectorAll('.nav-button').forEach(button => {
                if (button.id === `nav-${viewId.replace('-view', '')}`) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            // Refresh content for the displayed view
            if (viewId === 'recommendations-view') {
                displayRecommendedBooks();
            } else if (viewId === 'bookshelf-view') {
                displayBookShelfBooks();
            } else if (viewId === 'beth-deleted-books-view') {
                displayBethsDeletedBooks();
            } else if (viewId === 'flagged-books-view') {
                displayFlaggedBooks();
            } else if (viewId === 'admin-approved-books-view') {
                displayAdminApprovedBooks();
            }
        }


        // --- Utility Functions ---

        /**
         * Generates HTML for a star rating based on a given numerical rating (out of 5).
         * Supports full and half stars.
         * @param {number} rating - The numerical rating (e.g., 4.5).
         * @returns {string} HTML string for the star rating.
         */
        function getStarRatingHtml(rating) {
            const maxStars = 5;
            let starsHtml = '';
            for (let i = 1; i <= maxStars; i++) {
                if (rating >= i) {
                    starsHtml += `<svg class="w-5 h-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.538 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.538-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.462a1 1 0 00.95-.69l1.07-3.292z"></path></svg>`;
                } else if (rating > i - 1 && rating < i) {
                    // Unique ID for each gradient to prevent conflicts
                    const gradientId = `half-star-gradient-${Math.random().toString(36).substring(2, 9)}`;
                    starsHtml += `<svg class="w-5 h-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="${gradientId}" x1="0%" y1="0%" y2="0%"><stop offset="${(rating % 1) * 100}%" stop-color="currentColor"/><stop offset="${(rating % 1) * 100}%" stop-color="#d1d5db"/></linearGradient></defs><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.538 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.538-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.462a1 1 0 00.95-.69l1.07-3.292z" fill="url(#${gradientId})"></path></svg>`;
                } else {
                    starsHtml += `<svg class="w-5 h-5 text-gray-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.538 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.538-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.462a1 1 0 00.95-.69l1.07-3.292z"></path></svg>`;
                }
            }
            return `<div class="star-rating">${starsHtml}</div>`;
        }

        /**
         * Handles the "Click to Pick!" button action.
         * Notifies the admin, moves the book to Beth's bookshelf (marked as 'picked'),
         * and removes it from the main recommendations.
         * @param {string} bookWorkKey - The workKey of the book Beth picked.
         */
        async function handlePickBook(bookWorkKey) {
            const pickedBook = window.recommendedBooks.find(book => book.workKey === bookWorkKey);

            if (pickedBook) {
                console.log(`handlePickBook: Beth picked book with workKey: ${bookWorkKey}`);
                // Send alert BEFORE modifying pickedBook, as sendAdminAlert uses current book data
                await sendAdminAlert('picked_book', bookWorkKey); 
                
                // Updated message for Beth: no reference to admin-only tab
                showMessage(`You've picked "${pickedBook.title}"! The admin has been notified.`, false, false);
                
                pickedBook.userRating = 'picked'; 

                // Check if book already exists on bookshelf by workKey to prevent duplicates
                const isAlreadyOnShelf = window.bookShelfBooks.some(book => book.workKey === pickedBook.workKey);
                if (!isAlreadyOnShelf) {
                    await setBookInFirestore(pickedBook, 'bookshelf_books');
                    console.log(`handlePickBook: Added "${pickedBook.title}" to bookshelf.`);
                } else {
                    // If already on shelf, just update its rating
                    await setBookInFirestore(pickedBook, 'bookshelf_books');
                    console.log(`handlePickBook: Updated "${pickedBook.title}" on bookshelf.`);
                }

                // Remove from recommended list
                await deleteBookFromFirestore(bookWorkKey, 'recommended_books');
            }
        }

        /**
         * Sends an alert to the admin indicating Beth is ready for more recommendations.
         */
        function requestMoreRecommendations() {
            console.log("requestMoreRecommendations: Beth clicked 'Ready for More Recommendations!'");
            sendAdminAlert('request_more_recs');
            showMessage("Your request for more recommendations has been sent to the admin!", false, false);
        }

        /**
         * Sends an alert message to the admin panel.
         * @param {string} type - The type of alert (e.g., 'picked_book', 'request_more_recs', 'recommendations_generation_started').
         * @param {string} [data=''] - Additional data related to the alert (e.g., book workKey).
         */
        async function sendAdminAlert(type, data = '') {
            const timestamp = new Date().toLocaleString();
            let message = '';

            if (type === 'picked_book') {
                const book = window.recommendedBooks.find(b => b.workKey === data);
                message = `Beth picked: "${book ? book.title : 'Unknown Book'}" (WorkKey: ${data})`;
            } else if (type === 'request_more_recs') {
                message = `Beth is ready for more book recommendations!`;
            } else if (type === 'passed_book') { // Added for passed books
                const book = window.recommendedBooks.find(b => b.workKey === data);
                message = `Beth passed on: "${book ? book.title : 'Unknown Book'}" (WorkKey: ${data})`;
            } else if (type === 'recommendations_generation_started') { // New alert type
                message = `Admin initiated new recommendation generation.`;
            }

            const newAlert = { message: message, timestamp: timestamp };
            console.log(`sendAdminAlert: Preparing to send alert. Type: "${type}", Data: "${data}", Message: "${message}"`);
            // addAdminAlertToFirestore now returns the alert with its Firestore ID
            const addedAlert = await addAdminAlertToFirestore(newAlert);
            if (addedAlert) {
                console.log("sendAdminAlert: Alert successfully added to Firestore:", addedAlert);
            } else {
                console.error("sendAdminAlert: Failed to add alert to Firestore.");
            }
        }

        /**
         * Displays current admin alerts in the admin panel.
         */
        function displayAdminAlerts() {
            const adminAlertsContainer = document.getElementById('admin-alerts-container');
            const adminAlertsList = document.getElementById('admin-alerts-list');
            const noAdminAlertsMessage = document.getElementById('no-admin-alerts-message');

            // Add null checks for robustness
            if (!adminAlertsContainer) {
                console.error("ERROR: 'admin-alerts-container' element not found. Cannot display admin alerts.");
                return;
            }
            if (!adminAlertsList) {
                console.error("ERROR: 'admin-alerts-list' element not found. Cannot display admin alerts.");
                return;
            }
            if (!noAdminAlertsMessage) {
                console.error("ERROR: 'no-admin-alerts-message' element not found. Cannot display admin alerts.");
                return;
            }

            console.log("displayAdminAlerts: Called. Current alerts in window.adminAlerts:", window.adminAlerts.length);

            // Data is now sourced from window.adminAlerts (updated by Firestore listener)
            adminAlertsList.innerHTML = ''; // Clear existing alerts

            if (window.adminAlerts.length === 0) {
                adminAlertsContainer.classList.add('hidden');
                noAdminAlertsMessage.classList.remove('hidden');
                console.log("displayAdminAlerts: Hiding admin alerts container, showing no alerts message.");
            } else {
                adminAlertsContainer.classList.remove('hidden');
                noAdminAlertsMessage.classList.add('hidden');
                console.log("displayAdminAlerts: Showing admin alerts container.");
                window.adminAlerts.forEach(alert => {
                    const alertItem = document.createElement('div');
                    alertItem.className = 'admin-alert-item';
                    alertItem.innerHTML = `
                        <span>${escapeHtmlAttribute(alert.message)} <span class="text-gray-500 text-xs ml-2">(${escapeHtmlAttribute(alert.timestamp)})</span></span>
                        <button class="dismiss-button dismiss-admin-alert-btn" data-id="${escapeJsStringForHtmlAttribute(alert.id)}">Dismiss</button>
                    `;
                    adminAlertsList.appendChild(alertItem);
                });

                // Attach event listeners to the newly created buttons
                adminAlertsList.querySelectorAll('.dismiss-admin-alert-btn').forEach(button => {
                    button.addEventListener('click', (event) => dismissAdminAlert(event.currentTarget.dataset.id));
                });
            }
        }

        /**
         * Dismisses an admin alert, removing it from the list.
         * @param {string} id - The unique document ID of the alert to dismiss.
         */
        async function dismissAdminAlert(id) {
            console.log(`dismissAdminAlert: Attempting to dismiss alert with ID: ${id}`);
            await deleteAdminAlertFromFirestore(id);
        }


        /**
         * Displays a temporary message or a loading indicator in a modal box.
         * @param {string} text - The message text or content for the loader.
         * @param {boolean} [isLoader=false] - True if a loader should be shown.
         * @param {boolean} [isLlmInsight=false] - True if the message is an LLM insight (stays open until closed).
         */
        function showMessage(text, isLoader = false, isLlmInsight = false) {
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const closeButton = document.getElementById('message-box-close');

            // Add null checks for robustness
            if (!messageBox || !messageText || !closeButton) {
                console.error("ERROR: One or more message box DOM elements not found. Cannot display message.");
                return; // Exit if elements are missing
            }

            messageText.innerHTML = isLoader ? `<div class="loader"></div><p class="mt-4">${text}</p>` : text;
            messageBox.classList.toggle('llm-insight', isLlmInsight); // Add/remove LLM specific styling
            closeButton.style.display = isLoader ? 'none' : 'block'; // Hide close button for loaders
            messageBox.style.display = 'block';
            console.log(`showMessage: Displaying message: "${text}", isLoader: ${isLoader}, isLlmInsight: ${isLlmInsight}`);


            if (!isLoader && !isLlmInsight) { // Auto-hide for simple messages (like "You picked...")
                setTimeout(() => {
                    messageBox.style.display = 'none';
                    console.log("showMessage: Auto-hiding message box.");
                }, 5000);
            } else if (isLlmInsight) { // Keep LLM insight open until closed manually
                // Re-attach listener to ensure it's only active for this specific message
                closeButton.removeEventListener('click', closeMessageBox); // Remove previous listener if any
                closeButton.addEventListener('click', closeMessageBox, { once: true });
            }
        }

        /** Helper function to close the message box */
        function closeMessageBox() {
            const messageBox = document.getElementById('message-box');
            if (messageBox) {
                messageBox.style.display = 'none';
                messageBox.classList.remove('llm-insight');
                console.log("closeMessageBox: Message box closed.");
            }
        }

        /**
         * Seeds Beth's bookshelf with initial "loved" books if they are not already present.
         */
        async function seedInitialBookshelf() {
            console.log("seedInitialBookshelf: Function started.");
            if (localStorage.getItem(MIGRATED_INITIAL_BOOKSHELF_FLAG) === 'true') {
                console.log("seedInitialBookshelf: Initial bookshelf seeding already completed (flag found in localStorage).");
                return;
            }

            const initialBooks = [
                { url: 'https://openlibrary.org/works/OL24311121W/Rock_Paper_Scissors', userRating: 'love' },
                { url: 'https://openlibrary.org/works/OL19096402W/The_Silent_Patient', userRating: 'love' },
                { url: 'https://openlibrary.org/works/OL19749472W/Then_she_was_gone', userRating: 'love' }
            ];

            console.log("seedInitialBookshelf: Attempting to seed initial bookshelf with", initialBooks.length, "books.");
            for (const bookInfo of initialBooks) {
                console.log(`seedInitialBookshelf: Processing book URL: ${bookInfo.url}`);
                const workKeyMatch = bookInfo.url.match(/\/works\/(OL\d+W)/);
                if (!workKeyMatch || !workKeyMatch[1]) {
                    console.warn(`seedInitialBookshelf: Invalid Open Library Work URL for seeding: ${bookInfo.url}. Skipping.`);
                    continue;
                }
                const workKey = workKeyMatch[1];
                console.log(`seedInitialBookshelf: Extracted workKey: ${workKey}`);

                // Check if the book already exists in Beth's bookshelf
                // IMPORTANT: Ensure window.bookShelfBooks is populated by its listener BEFORE this check
                // This is why seedInitialBookshelf is called after setupFirestoreListeners
                const isAlreadyOnShelf = window.bookShelfBooks.some(book => book.workKey === workKey);
                console.log(`seedInitialBookshelf: Is book with workKey ${workKey} already on bookshelf? ${isAlreadyOnShelf}`);


                if (!isAlreadyOnShelf) {
                    console.log(`seedInitialBookshelf: Fetching details for ${workKey}...`);
                    const bookDetails = await fetchBookDetailsFromOpenLibrary(workKey);
                    if (bookDetails) {
                        const bookToSave = {
                            ...bookDetails,
                            userRating: bookInfo.userRating,
                            source: 'Initial Seeding'
                        };
                        console.log(`seedInitialBookshelf: Details fetched for "${bookDetails.title}". Attempting to save to bookshelf.`);
                        await setBookInFirestore(bookToSave, 'bookshelf_books');
                        console.log(`seedInitialBookshelf: Successfully seeded "${bookToSave.title}" as 'loved' on bookshelf.`);
                    } else {
                        console.warn(`seedInitialBookshelf: Failed to fetch details for seeding book: ${bookInfo.url}. Skipping.`);
                    }
                } else {
                    console.log(`seedInitialBookshelf: "${bookInfo.url}" (workKey: ${workKey}) already exists on bookshelf. Skipping seeding.`);
                }
            }
            localStorage.setItem(MIGRATED_INITIAL_BOOKSHELF_FLAG, 'true');
            console.log("seedInitialBookshelf: Initial bookshelf seeding process completed. Flag set in localStorage.");
        }

        /**
         * Initializes the main application after successful PIN login.
         * @param {boolean} isAdminLogin - True if the login was via the admin PIN.
         */
        async function initializeAppContent(isAdminLogin = false) {
            // Set the fixed admin user ID
            window.adminUserId = BETH_FIREBASE_USER_ID;
            console.log("App Content Initialized: Admin User ID set to", window.adminUserId);
            console.log(`initializeAppContent: isAdminLogin = ${isAdminLogin}`);

            // Perform migrations first
            console.log("Initializing App Content: Starting local storage migrations...");
            await migrateLocalStorageToFirestore(RECOMMENDED_BOOKS_KEY, MIGRATED_RECOMMENDED_BOOKS_FLAG, 'recommended_books');
            await migrateLocalStorageToFirestore(BOOK_SHELF_BOOKS_KEY, MIGRATED_BOOKSHELF_BOOKS_FLAG, 'bookshelf_books');
            await migrateLocalStorageToFirestore(FLAGGED_BOOKS_KEY, MIGRATED_FLAGGED_BOOKS_FLAG, 'flagged_books', window.adminUserId);
            await migrateLocalStorageToFirestore(BETH_DELETED_BOOKS_KEY, MIGRATED_BETH_DELETED_BOOKS_FLAG, 'beth_deleted_books');
            await migrateLocalStorageToFirestore(ADMIN_ALERTS_KEY, MIGRATED_ADMIN_ALERTS_FLAG, 'admin_alerts', window.adminUserId);
            await migrateLocalStorageToFirestore(ADMIN_PENDING_RECS_KEY, MIGRATED_ADMIN_PENDING_RECS_FLAG, 'admin_pending_recs', window.adminUserId);
            await migrateLocalStorageToFirestore(ADMIN_APPROVED_BOOKS_KEY, MIGRATED_ADMIN_APPROVED_BOOKS_FLAG, 'admin_approved_books', window.adminUserId);

            // Negative feedback migration (special case as it's a simple array of strings)
            const oldNegativeFeedback = localStorage.getItem(BETH_NEGATIVE_FEEDBACK_KEY);
            if (oldNegativeFeedback && localStorage.getItem(MIGRATED_BETH_NEGATIVE_FEEDBACK_FLAG) !== 'true') {
                try {
                    const terms = JSON.parse(oldNegativeFeedback);
                    if (Array.isArray(terms) && terms.length > 0) {
                        console.log(`Initializing App Content: Migrating ${terms.length} negative feedback terms...`);
                        for (const term of terms) {
                            await addNegativeFeedbackToFirestore(term);
                        }
                        localStorage.setItem(MIGRATED_BETH_NEGATIVE_FEEDBACK_FLAG, 'true');
                        localStorage.removeItem(BETH_NEGATIVE_FEEDBACK_KEY);
                        console.log('Initializing App Content: Negative feedback migration completed.');
                    }
                } catch (e) {
                    console.error("Initializing App Content: Error migrating negative feedback:", e);
                }
            }
            console.log("Initializing App Content: Local storage migrations completed.");

            // Setup Firestore listeners after all migrations are potentially done
            setupFirestoreListeners();
            
            // Seed initial bookshelf books (after listeners are set up so window.bookShelfBooks is populated)
            await seedInitialBookshelf();

            // Hide login screen
            document.getElementById('login-screen').classList.add('hidden');
            
            // Show splash screen
            document.getElementById('splash-screen').classList.remove('hidden');
            console.log("initializeAppContent: Showing splash screen.");

            // Set admin panel visibility based on login type
            setAdminUIVisibility(isAdminLogin);

            // The "Ready for More Recommendations!" button is now always visible for logged-in users.
            document.getElementById('request-more-recs-container')?.classList.remove('hidden');
            console.log("initializeAppContent: 'Ready for More Recommendations' button visible.");
        }

        /**
         * Handles logging out, returning to the login screen.
         */
        function handleLogout() {
            // Hide all main content views
            document.getElementById('main-content').classList.add('hidden');
            document.getElementById('splash-screen').classList.add('hidden');
            // Show login screen
            document.getElementById('login-screen').classList.remove('hidden');
            // Clear PIN input
            document.getElementById('pin-input').value = '';
            // Reset admin UI visibility
            setAdminUIVisibility(false); // Hide admin elements on logout
            console.log("Logged out. Returning to login screen.");
        }

        /**
         * Displays a message for PIN recovery.
         */
        function showPinRecoveryMessage() {
            showMessage(
                `If you've forgotten your PIN, please contact the administrator (e.g., check the source code for the hardcoded PINs).`,
                false,
                true // Keep open until manually closed
            );
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Set the current year in the footer
            const currentYearElement = document.getElementById('current-year');
            if (currentYearElement) {
                currentYearElement.textContent = new Date().getFullYear();
            }

            // Explicitly hide elements on load to ensure correct initial state
            // ONLY HIDE THE VIEWS, NOT THE MAIN CONTENT CONTAINER
            document.getElementById('admin-search-panel')?.classList.add('hidden');
            document.getElementById('nav-flagged-books')?.classList.add('hidden');
            document.getElementById('nav-admin-approved-books')?.classList.add('hidden');
            document.getElementById('request-more-recs-container')?.classList.add('hidden'); // Initially hidden until Beth logs in
            
            // Ensure all main content sections are hidden initially, but the main-content div is visible
            document.getElementById('recommendations-view')?.classList.add('hidden');
            document.getElementById('bookshelf-view')?.classList.add('hidden');
            document.getElementById('beth-deleted-books-view')?.classList.add('hidden');
            document.getElementById('flagged-books-view')?.classList.add('hidden');
            document.getElementById('admin-approved-books-view')?.classList.add('hidden');

            document.getElementById('splash-screen')?.classList.add('hidden'); // New splash screen, hidden by default
            document.getElementById('login-screen')?.classList.remove('hidden'); // Show login screen initially
            console.log("DOMContentLoaded: Initial UI state set.");


            // --- IMPORTANT: Firebase Initialization for GitHub Deployment ---
            // When deploying to GitHub, you need to provide your actual Firebase config.
            // Get this from your Firebase project settings (Project settings > General > Your apps > Web app > Config).
            // This config is now directly provided by the user.
            const firebaseConfig = {
                apiKey: "AIzaSyAFy0zdwfRbLuOHLvrjRpCo1WVAM_6JES4",
                authDomain: "beths-book-club.firebaseapp.com",
                projectId: "beths-book-club",
                storageBucket: "beths-book-club.firebasestorage.app",
                messagingSenderId: "383122582606",
                appId: "1:383122582606:web:b187ccfa0bcfeaba7a671f",
                measurementId: "G-X584KXZ8TX"
            };

            try {
                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp); // Auth service initialized, but not used for PIN login
                window.analytics = getAnalytics(window.firebaseApp); // Initialize analytics
                console.log("Firebase initialized successfully.");
            } catch (error) {
                console.error("ERROR: Failed to initialize Firebase:", error);
                showMessage(`Failed to initialize Firebase. Please check your console for errors.`, false, true);
                return; // Stop execution if Firebase initialization fails
            }

            // --- PIN Login Event Listener ---
            const pinInput = document.getElementById('pin-input');
            const loginButton = document.getElementById('login-button');
            const loginMessage = document.getElementById('login-message');

            if (loginButton) {
                loginButton.addEventListener('click', () => {
                    console.log("Login button clicked.");
                    const enteredPin = pinInput ? pinInput.value : '';
                    if (enteredPin === BETH_PIN) {
                        loginMessage.textContent = '';
                        console.log("Beth's PIN entered. Initializing app for Beth.");
                        initializeAppContent(false); // Not admin login
                    } else if (enteredPin === ADMIN_PIN) {
                        loginMessage.textContent = '';
                        console.log("Admin PIN entered. Initializing app for Admin.");
                        initializeAppContent(true); // Admin login
                    } else {
                        loginMessage.textContent = 'Incorrect PIN. Please try again.';
                        loginMessage.classList.remove('hidden');
                        console.log("Incorrect PIN entered.");
                    }
                });
            }

            if (pinInput) {
                pinInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        loginButton?.click();
                    }
                });
            }

            // --- Event Listeners for Static Elements (No longer inline onclick) ---

            // Navigation Buttons
            document.getElementById('nav-recommendations')?.addEventListener('click', () => showView('recommendations-view'));
            document.getElementById('nav-bookshelf')?.addEventListener('click', () => showView('bookshelf-view'));
            document.getElementById('nav-beth-deleted-books')?.addEventListener('click', () => showView('beth-deleted-books-view'));
            document.getElementById('nav-flagged-books')?.addEventListener('click', () => showView('flagged-books-view'));
            document.getElementById('nav-admin-approved-books')?.addEventListener('click', () => showView('admin-approved-books-view'));

            // Admin Panel Buttons
            document.getElementById('search-button')?.addEventListener('click', () => {
                const queryInput = document.getElementById('search-input');
                const query = queryInput ? queryInput.value.trim() : '';
                if (query) {
                    searchBooks(query);
                } else {
                    showMessage('Please enter a book title or author to search.', false, false);
                }
            });
            document.getElementById('recommend-button')?.addEventListener('click', generateRecommendations);
            document.getElementById('manual-add-button')?.addEventListener('click', addBookFromOpenLibraryUrl);
            document.getElementById('evaluate-book-button')?.addEventListener('click', evaluateBookForBeth);
            document.getElementById('request-more-recs-button')?.addEventListener('click', requestMoreRecommendations);

            // Input field Enter key listeners
            document.getElementById('search-input')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('search-button')?.click();
            });
            document.getElementById('manual-add-url-input')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('manual-add-button')?.click();
            });
            document.getElementById('evaluate-book-url-input')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('evaluate-book-button')?.click();
            });

            // Logout Button
            document.getElementById('logout-button')?.addEventListener('click', handleLogout);

            // Forgot PIN Button
            document.getElementById('forgot-pin-button')?.addEventListener('click', showPinRecoveryMessage);

            // Splash Screen Continue Button
            document.getElementById('splash-continue-button')?.addEventListener('click', () => {
                document.getElementById('splash-screen')?.classList.add('hidden');
                document.getElementById('main-content')?.classList.remove('hidden'); // Ensure main-content is visible
                showView('recommendations-view'); // Transition to main recommendations view
            });

            // Close button for message box (initial setup)
            document.getElementById('message-box-close')?.addEventListener('click', closeMessageBox);
        });
    </script>
    <style>
        /* Custom styles for the Inter font and overall look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background for matte, earthy feel */
            color: #334155; /* Darker text for contrast */
            line-height: 1.6;
        }
        .book-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            opacity: 0; /* Start hidden for fade-in animation */
            transform: translateY(20px); /* Start slightly below for slide-up effect */
            animation: fadeInSlideUp 0.5s ease-out forwards; /* Apply animation */
        }
        .book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        /* Keyframe animation for fade-in and slide-up */
        @keyframes fadeInSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Ensure images maintain aspect ratio and fit within their containers */
        .book-image {
            width: 100%;
            height: 250px; /* Fixed height for consistency */
            object-fit: cover; /* Cover the area, cropping if necessary */
            border-radius: 0.5rem; /* Rounded corners for images */
        }

        /* Styles for smaller bookshelf cards */
        .bookshelf-card-small {
            width: 160px; /* Fixed smaller width for bookshelf cards */
            flex-shrink: 0; /* Prevent shrinking in flex containers */
            margin: 0.5rem; /* Small margin around cards */
            text-align: center;
        }

        .bookshelf-card-small .book-image {
            height: 180px; /* Smaller height for images in bookshelf */
        }

        .bookshelf-card-small .p-6 {
            padding: 0.75rem; /* Reduced padding for smaller cards */
        }

        .bookshelf-card-small .text-xl {
            font-size: 1rem; /* Smaller title font size */
        }

        .bookshelf-card-small .text-sm {
            font-size: 0.75rem; /* Smaller author/year font size */
        }

        .bookshelf-card-small .book-description {
            display: -webkit-box;
            -webkit-line-clamp: 3; /* Limit description to 3 lines for smaller cards */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.8rem; /* Smaller description font size */
        }

        .bookshelf-card-small .star-rating svg {
            width: 1rem; /* Smaller stars for bookshelf */
            height: 1rem;
        }


        /* Responsive adjustments for description text (main view) */
        .book-description {
            display: -webkit-box;
            -webkit-line-clamp: 4; /* Limit to 4 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        @media (min-width: 768px) {
            .book-description {
                -webkit-line-clamp: 6; /* More lines on larger screens */
            }
        }
        /* Remove underline from links within book cards */
        .book-link {
            text-decoration: none;
            color: inherit; /* Inherit text color from parent */
            display: flex; /* Make the link fill its container */
            flex-direction: column; /* Stack content vertically */
            height: 100%; /* Ensure the link takes full height of the card */
        }
        /* Star rating styles */
        .star-rating {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            justify-content: center; /* Center stars in small cards */
        }
        .star-rating svg {
            width: 1.25rem; /* Size of the star icon */
            height: 1.25rem;
            fill: #facc15; /* Yellow color for filled stars */
            stroke: #facc15; /* Stroke color for consistency */
            margin-right: 0.125rem; /* Small space between stars */
        }
        .star-rating .empty-star {
            fill: #d1d5db; /* Light gray for empty stars */
            stroke: #d1d5db;
        }

        /* Button styling */
        .action-button {
            background-color: #059669; /* Emerald 600 - Green */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            border: none; /* Remove default button border */
            width: fit-content; /* Adjust width to content */
            margin-top: auto; /* Push button to the bottom of the card */
        }
        .action-button:hover {
            background-color: #047857; /* Emerald 700 - Darker Green on hover */
            transform: translateY(-1px);
        }
        .action-button:active {
            transform: translateY(0);
        }

        /* Specific button colors */
        .action-button.recommend-btn {
            background-color: #e11d48; /* Rose 600 - Pink */
        }
        .action-button.recommend-btn:hover {
            background-color: #be123c; /* Rose 700 - Darker Pink on hover */
        }
        .action-button.insight-btn {
            background-color: #d97706; /* Amber 600 - Yellow */
        }
        .action-button.insight-btn:hover {
            background-color: #b45309; /* Amber 700 - Darker Yellow on hover */
        }
        .action-button.pass-btn { /* New style for pass button */
            background-color: #6b7280; /* Gray 500 */
        }
        .action-button.pass-btn:hover {
            background-color: #4b5563; /* Gray 600 */
        }
        .action-button.red-flag-btn { /* New style for red flag button */
            background-color: #dc2626; /* Red 600 */
        }
        .action-button.red-flag-btn:hover {
            background-color: #b91c1c; /* Red 700 */
        }
        .nav-button {
            background-color: transparent;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .nav-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .nav-button.active {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .remove-admin-button {
            background-color: #dc2626; /* Red-600 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            width: 100%; /* Full width within its container */
            margin-top: 1rem; /* Space above */
        }

        .remove-admin-button:hover {
            background-color: #b91c1c; /* Red-700 */
        }

        /* Review buttons specific styling */
        .review-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center; /* Center the buttons */
        }
        .review-button {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid #cbd5e1; /* Light gray border */
            background-color: #f8fafc; /* Light background */
            color: #475569; /* Slate 700 */
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        }
        .review-button:hover {
            background-color: #e2e8f0; /* Lighter on hover */
        }
        .review-button.selected-mid {
            background-color: #fca5a5; /* Red-300 */
            border-color: #ef4444; /* Red-500 */
            color: #7f1d1d; /* Red-900 */
        }
        .review-button.selected-like {
            background-color: #a7f3d0; /* Green-200 */
            border-color: #10b981; /* Green-500 */
            color: #064e3b; /* Green-900 */
        }
        .review-button.selected-love {
            background-color: #bfdbfe; /* Blue-200 */
            border-color: #3b82f6; /* Blue-500 */
            color: #1e3a8a; /* Blue-900 */
        }

        /* Styles for review buttons inside small bookshelf cards */
        .bookshelf-card-small .review-buttons {
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 0.25rem; /* Smaller gap */
            margin-top: 0.5rem; /* Reduced margin */
        }
        .bookshelf-card-small .review-button {
            padding: 0.3rem 0.6rem; /* Smaller padding */
            font-size: 0.7rem; /* Smaller font size */
        }


        /* Message box for pick confirmation and LLM insights */
        .message-box {
            position: fixed;
            top: 50% ;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 1.5rem 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            font-size: 1.125rem;
            font-weight: 500;
            color: #1f2937;
            max-width: 90%; /* Ensure it's responsive */
            word-wrap: break-word; /* Prevent overflow for long text */
        }
        .message-box.llm-insight {
            max-width: 600px; /* Wider for LLM insights */
            text-align: left;
            font-size: 1rem;
        }


        /* Loader styling */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #059669; /* Emerald 600 - Green */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Source tag styling */
        .source-tag {
            display: inline-block;
            background-color: #e0f2f7; /* Light blue */
            color: #083344; /* Dark blue text */
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }

        /* Admin Alert specific styling */
        .admin-alert-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .admin-alert-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #fef3c7; /* Light yellow for alerts */
            border-left: 4px solid #f59e0b; /* Amber border */
            border-radius: 0.25rem;
            font-size: 0.9rem;
            color: #78350f; /* Darker amber text */
        }
        .admin-alert-item:last-child {
            margin-bottom: 0;
        }
        .admin-alert-item .dismiss-button {
            background-color: #f59e0b;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .admin-alert-item .dismiss-button:hover {
            background-color: #d97706;
        }

        /* New styles for admin pending recommendations */
        .admin-pending-recs-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .admin-pending-rec-item {
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #e0f2fe; /* Light blue for pending */
            border-left: 4px solid #3b82f6; /* Blue border */
            border-radius: 0.25rem;
            font-size: 0.9rem;
            color: #1e40af; /* Darker blue text */
        }
        .admin-pending-rec-item .book-info {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .admin-pending-rec-item .approve-button {
            background-color: #3b82f6;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            align-self: flex-end; /* Align button to the right */
        }
        .admin-pending-rec-item .approve-button:hover {
            background-color: #2563eb;
        }

        /* New styles for admin approved books */
        .admin-approved-books-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .admin-approved-book-item {
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #d1fae5; /* Light green for approved */
            border-left: 4px solid #10b981; /* Green border */
            border-radius: 0.25rem;
            font-size: 0.9rem;
            color: #065f46; /* Darker green text */
        }
        .admin-approved-book-item .book-info {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .admin-approved-book-item .move-to-recs-button {
            background-color: #10b981;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            align-self: flex-end;
        }
        .admin-approved-book-item .move-to-recs-button:hover {
            background-color: #059669;
        }
    </style>
</head>
<body class="antialiased">
    <!-- Message box for pick confirmation and other messages -->
    <div id="message-box" class="message-box">
        <p id="message-text"></p>
        <button id="message-box-close" class="mt-4 px-4 py-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700">Close</button>
    </div>

    <!-- Login Screen -->
    <div id="login-screen" class="min-h-screen flex items-center justify-center bg-gray-100">
        <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-sm text-center">
            <h2 class="text-2xl font-bold mb-6 text-gray-800">Beth's Book Club Login</h2>
            <input type="password" id="pin-input" placeholder="Enter 4-digit PIN" maxlength="4"
                   class="w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700 text-center text-xl tracking-widest">
            <button id="login-button" class="action-button w-full mt-6 px-6 py-3 bg-emerald-600 hover:bg-emerald-700">Login</button>
            <p id="login-message" class="text-red-500 mt-4 hidden"></p>
            <button id="forgot-pin-button" class="text-blue-600 hover:underline mt-4 text-sm">Forgot PIN?</button>
        </div>
    </div>

    <!-- Splash Screen (Hidden by default, shown after successful login) -->
    <div id="splash-screen" class="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-emerald-500 to-emerald-700 text-white p-4 hidden">
        <h2 class="text-5xl font-extrabold mb-6 text-center animate-pulse">Welcome, Beth!</h2>
        <p class="text-xl text-center mb-8 max-w-lg">
            Your personalized book recommendations are ready. Let's find your next favorite read!
        </p>
        <button id="splash-continue-button" class="action-button px-8 py-4 text-lg bg-white text-emerald-700 hover:bg-gray-100 transition-colors duration-300">
            Start Reading
        </button>
    </div>

    <!-- Main Content Area (Now always in DOM, its children are hidden) -->
    <div id="main-content" class="min-h-screen flex flex-col">
        <!-- Header Section -->
        <header class="bg-gradient-to-r from-emerald-800 to-gray-900 text-white shadow-lg py-6 px-4 sm:px-6 lg:px-8">
            <div class="max-w-7xl mx-auto flex flex-col sm:flex-row justify-between items-center">
                <h1 class="text-4xl font-extrabold tracking-tight mb-2 sm:mb-0 flex items-center gap-2" id="main-title">
                    Beth's Book Club
                </h1>
                <p class="text-xl opacity-90">Curated reads for you, my love.</p>
                <!-- Logout Button -->
                <button id="logout-button" class="action-button bg-red-500 hover:bg-red-600 px-4 py-2 text-sm mt-4 sm:mt-0">Logout</button>
            </div>
            <nav class="max-w-7xl mx-auto mt-4 flex justify-center space-x-4">
                <button id="nav-recommendations" class="nav-button active">Recommended Reads</button>
                <button id="nav-bookshelf" class="nav-button">My Bookshelf</button>
                <!-- New tab for Beth's deleted books -->
                <button id="nav-beth-deleted-books" class="nav-button hidden">Deleted Books</button>
                <!-- Admin-only tabs, initially hidden and controlled by PIN login -->
                <button id="nav-flagged-books" class="nav-button hidden">Flagged Books</button>
                <button id="nav-admin-approved-books" class="nav-button hidden">Admin Approved</button>
            </nav>
        </header>

        <!-- Admin Search Section (Initially Hidden and controlled by PIN login) -->
        <section id="admin-search-panel" class="py-8 px-4 sm:px-6 lg:px-8 bg-gray-100 border-b border-gray-200 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">Admin: Find & Add Books</h2>

                <!-- Admin Alerts Container -->
                <div id="admin-alerts-container" class="admin-alert-container hidden">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Admin Alerts</h3>
                    <div id="admin-alerts-list">
                        <!-- Admin alerts will be displayed here -->
                    </div>
                    <p id="no-admin-alerts-message" class="text-center text-gray-600 mt-4 hidden"></p>
                </div>

                <!-- Admin Pending Recommendations Container -->
                <div id="admin-pending-recs-container" class="admin-pending-recs-container hidden">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Admin: Pending Recommendations</h3>
                    <div id="admin-pending-recs-list">
                        <!-- Pending recommendations will be displayed here -->
                    </div>
                    <p id="no-admin-pending-recs-message" class="text-center text-gray-600 mt-4 hidden"></p>
                </div>

                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-8">
                    <input type="text" id="search-input" placeholder="Search by title or author..."
                           class="flex-grow p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700">
                    <button id="search-button" class="action-button px-6 py-3">Search Books</button>
                    <button id="recommend-button" class="action-button recommend-btn px-6 py-3">Get Recommendations</button>
                </div>

                <div class="mt-8 flex flex-col sm:flex-row items-center justify-center gap-4">
                    <input type="text" id="manual-add-url-input" placeholder="Paste Open Library Work URL (e.g., https://openlibrary.org/works/OL12345W)"
                           class="flex-grow p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700">
                    <button id="manual-add-button" class="action-button px-6 py-3 bg-blue-600 hover:bg-blue-700">Add Manually</button>
                </div>

                <!-- New: Evaluate Book for Beth -->
                <div class="mt-8 flex flex-col sm:flex-row items-center justify-center gap-4">
                    <input type="text" id="evaluate-book-url-input" placeholder="Evaluate Book for Beth (Open Library Work URL)"
                           class="flex-grow p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700">
                    <button id="evaluate-book-button" class="action-button px-6 py-3 bg-purple-600 hover:bg-purple-700">Evaluate Book</button>
                </div>


                <div id="search-results" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mt-8">
                    <!-- Search results will be displayed here -->
                </div>
                <div id="search-loader" class="loader"></div>
                <p id="search-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Main Content Area for Curated Books -->
        <main id="recommendations-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 id="recommended-reads-heading" class="text-3xl font-bold text-center mb-10 text-gray-800">Recommended Reads (This Month)</h2>
                <div id="book-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                    <!-- Curated book cards will be dynamically inserted here by JavaScript -->
                </div>
                <p id="no-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
                <!-- New button for Beth to request more recommendations (visibility controlled by PIN login) -->
                <div id="request-more-recs-container" class="mt-10 text-center hidden">
                    <button id="request-more-recs-button" class="action-button px-8 py-4 text-lg bg-blue-500 hover:bg-blue-600">Ready for More Recommendations!</button>
                </div>
            </div>
        </main>

        <!-- Beth's Bookshelf Section -->
        <section id="bookshelf-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Beth's Bookshelf</h2>
                <!-- Adjusted grid for smaller cards on bookshelf -->
                <div id="bookshelf-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Books from the bookshelf will be dynamically inserted here -->
                </div>
                <p id="no-bookshelf-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Beth's Deleted Books Section (Always visible) -->
        <section id="beth-deleted-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Beth's Deleted Books</h2>
                <div id="beth-deleted-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Beth's deleted books will be dynamically inserted here -->
                </div>
                <p id="no-beth-deleted-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Admin Flagged Books Section (Initially Hidden and controlled by PIN login) -->
        <section id="flagged-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Admin: Flagged Books</h2>
                <div id="flagged-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Flagged books (passed/red-flagged) will be dynamically inserted here -->
                </div>
                <p id="no-flagged-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Admin Approved Books Section (Initially Hidden and controlled by PIN login) -->
        <section id="admin-approved-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Admin: Approved Books</h2>
                <div id="admin-approved-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Admin approved books will be dynamically inserted here -->
                </div>
                <p id="no-admin-approved-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </secti
