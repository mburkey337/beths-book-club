<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beth's Book Club</title>
    <!-- Tailwind CSS CDN for sleek styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs (Modular versions) -->
    <script type="module">
        console.log("Beth's Book Club script is loading...");

        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getAuth } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-analytics.js";

        // === CONFIGURATION ===
        const CONFIG = {
            BETH_PIN: '7288',
            ADMIN_PIN: '2384',
            BETH_FIREBASE_USER_ID: 'beth_unique_book_club_id_7288',
            BETH_GENRE_KEYWORDS: ['true crime', 'murder mystery', 'thriller', 'mystery', 'crime'],
            MIN_PUBLISH_YEAR: 2000,
            API_KEY: "AIzaSyCU2J_0zErEIPLl-3ejBABDM-NYKOg44Zk",
            OPEN_LIBRARY_SEARCH_URL: 'https://openlibrary.org/search.json?q=',
            OPEN_LIBRARY_WORK_URL: 'https://openlibrary.org/works/',
            OPEN_LIBRARY_COVER_URL: 'https://covers.openlibrary.org/b/id/',
            RECOMMENDATION_CONFIG: {
                TARGET_BOOKS: 8,
                MIN_SCORE_THRESHOLD: 65,
                MAX_API_CALLS: 40,
                API_DELAY_MS: 50
            }
        };

        const STORAGE_KEYS = {
            RECOMMENDED_BOOKS: 'recommendedBooks',
            BOOK_SHELF_BOOKS: 'bookShelfBooks',
            FLAGGED_BOOKS: 'flaggedBooks',
            BETH_DELETED_BOOKS: 'bethDeletedBooks',
            ADMIN_ALERTS: 'adminAlerts',
            ADMIN_PENDING_RECS: 'adminPendingRecommendations',
            ADMIN_APPROVED_BOOKS: 'adminApprovedBooks',
            BETH_NEGATIVE_FEEDBACK: 'bethNegativeFeedback'
        };

        const MIGRATION_FLAGS = {
            RECOMMENDED_BOOKS: 'migrated_recommended_books_v1',
            BOOKSHELF_BOOKS: 'migrated_bookshelf_books_v1',
            FLAGGED_BOOKS: 'migrated_flagged_books_v1',
            BETH_DELETED_BOOKS: 'migrated_beth_deleted_books_v1',
            ADMIN_ALERTS: 'migrated_admin_alerts_v1',
            ADMIN_PENDING_RECS: 'migrated_admin_pending_recs_v1',
            ADMIN_APPROVED_BOOKS: 'migrated_admin_approved_books_v1',
            BETH_NEGATIVE_FEEDBACK: 'migrated_beth_negative_feedback_v1',
            INITIAL_BOOKSHELF: 'migrated_initial_bookshelf_v1'
        };

        // === GLOBAL STATE ===
        class AppState {
            constructor() {
                this.firebaseApp = null;
                this.db = null;
                this.auth = null;
                this.analytics = null;
                this.adminUserId = null;
                this.firestoreAvailable = true;
                this.offlineModeNotified = false;
                this.uiReadyForDisplay = false;
                this.listenersReady = false;
                this.activeAbortControllers = new Set();
                
                // Data stores
                this.data = {
                    recommendedBooks: [],
                    bookShelfBooks: [],
                    flaggedBooks: [],
                    bethDeletedBooks: [],
                    adminAlerts: [],
                    adminPendingRecommendations: [],
                    adminApprovedBooks: []
                };
            }

            reset() {
                this.activeAbortControllers.forEach(controller => {
                    try { controller.abort(); } catch (e) { console.warn('Error aborting controller:', e); }
                });
                this.activeAbortControllers.clear();
                this.uiReadyForDisplay = false;
                this.listenersReady = false;
            }
        }

        const appState = new AppState();
        window.appState = appState; // For debugging

        // === UTILITY FUNCTIONS ===
        const utils = {
            safeGetElement(id) {
                const element = document.getElementById(id);
                if (!element) console.warn(`Element '${id}' not found`);
                return element;
            },

            escapeHtml(str) {
                if (typeof str !== 'string') str = String(str);
                return str.replace(/&/g, '&amp;')
                          .replace(/"/g, '&quot;')
                          .replace(/'/g, '&#x27;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;');
            },

            escapeJs(str) {
                if (typeof str !== 'string') str = String(str);
                return str.replace(/\\/g, '\\\\')
                          .replace(/'/g, "\\'")
                          .replace(/`/g, "\\`")
                          .replace(/\n/g, "\\n")
                          .replace(/\r/g, "\\r")
                          .replace(/\u2028/g, '\\u2028')
                          .replace(/\u2029/g, '\\u2029');
            },

            async delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            async withTimeout(promise, timeoutMs, errorMessage = 'Operation timed out') {
                const controller = new AbortController();
                appState.activeAbortControllers.add(controller);
                
                try {
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error(errorMessage)), timeoutMs)
                    );
                    return await Promise.race([promise, timeoutPromise]);
                } finally {
                    appState.activeAbortControllers.delete(controller);
                }
            },

            getStarRatingHtml(rating) {
                const maxStars = 5;
                let starsHtml = '';
                for (let i = 1; i <= maxStars; i++) {
                    if (rating >= i) {
                        starsHtml += `<svg class="w-5 h-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.538 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.538-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.462a1 1 0 00.95-.69l1.07-3.292z"></path></svg>`;
                    } else if (rating > i - 1 && rating < i) {
                        const gradientId = `half-star-gradient-${Math.random().toString(36).substring(2, 9)}`;
                        starsHtml += `<svg class="w-5 h-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><defs><linearGradient id="${gradientId}" x1="0%" y1="0%" y2="0%"><stop offset="${(rating % 1) * 100}%" stop-color="currentColor"/><stop offset="${(rating % 1) * 100}%" stop-color="#d1d5db"/></linearGradient></defs><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.538 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.538-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.462a1 1 0 00.95-.69l1.07-3.292z" fill="url(#${gradientId})"></path></svg>`;
                    } else {
                        starsHtml += `<svg class="w-5 h-5 text-gray-300" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.538 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.538-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.462a1 1 0 00.95-.69l1.07-3.292z"></path></svg>`;
                    }
                }
                return `<div class="star-rating">${starsHtml}</div>`;
            }
        };

        // === STORAGE LAYER ===
        class StorageManager {
            constructor() {
                this.cache = new Map();
            }

            getCollectionPath(collectionName, userId = null) {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const effectiveUserId = userId || appState.adminUserId;
                return effectiveUserId 
                    ? `artifacts/${appId}/users/${effectiveUserId}/${collectionName}`
                    : `artifacts/${appId}/public/data/${collectionName}`;
            }

            async saveToFirestore(item, collectionName, userId = null) {
                if (!appState.firestoreAvailable || !appState.db || !item.workKey) {
                    return this.saveToLocalStorage(item, collectionName);
                }

                try {
                    // Clean the item to remove undefined values before saving to Firestore
                    const cleanedItem = this.cleanObjectForFirestore(item);
                    
                    const docRef = doc(appState.db, this.getCollectionPath(collectionName, userId), item.workKey);
                    await setDoc(docRef, cleanedItem);
                    console.log(`Firestore: Saved "${item.title}" to ${collectionName}`);
                    return true;
                } catch (error) {
                    console.warn(`Firestore save failed, using localStorage:`, error);
                    if (error.code === 'permission-denied') {
                        appState.firestoreAvailable = false;
                        this.notifyOfflineMode();
                    }
                    return this.saveToLocalStorage(item, collectionName);
                }
            }

            cleanObjectForFirestore(obj) {
                const cleaned = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (value !== undefined) {
                        if (value === null || typeof value !== 'object' || Array.isArray(value)) {
                            cleaned[key] = value;
                        } else {
                            // Recursively clean nested objects
                            cleaned[key] = this.cleanObjectForFirestore(value);
                        }
                    }
                    // Skip undefined values entirely
                }
                return cleaned;
            }

            async deleteFromFirestore(workKey, collectionName, userId = null) {
                if (!appState.firestoreAvailable || !appState.db || !workKey) return false;

                try {
                    const docRef = doc(appState.db, this.getCollectionPath(collectionName, userId), workKey);
                    await deleteDoc(docRef);
                    console.log(`Firestore: Deleted ${workKey} from ${collectionName}`);
                    return true;
                } catch (error) {
                    console.error(`Firestore delete failed:`, error);
                    return false;
                }
            }

            saveToLocalStorage(item, collectionName) {
                try {
                    const collectionMap = {
                        'recommended_books': 'recommendedBooks',
                        'bookshelf_books': 'bookShelfBooks',
                        'flagged_books': 'flaggedBooks',
                        'beth_deleted_books': 'bethDeletedBooks',
                        'admin_pending_recs': 'adminPendingRecommendations',
                        'admin_approved_books': 'adminApprovedBooks'
                    };

                    const arrayName = collectionMap[collectionName];
                    if (arrayName && appState.data[arrayName]) {
                        appState.data[arrayName] = appState.data[arrayName].filter(b => b.workKey !== item.workKey);
                        appState.data[arrayName].push(item);
                        localStorage.setItem(STORAGE_KEYS[arrayName.toUpperCase()], JSON.stringify(appState.data[arrayName]));
                        console.log(`LocalStorage: Saved "${item.title}" to ${collectionName}`);
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.warn(`LocalStorage save failed:`, error);
                    return false;
                }
            }

            notifyOfflineMode() {
                if (!appState.offlineModeNotified && !appState.firestoreAvailable) {
                    console.warn("Running in offline mode using local storage.");
                    ui.showMessage("Working in offline mode. Changes will be saved locally.", false, false);
                    appState.offlineModeNotified = true;
                }
            }

            loadFromLocalStorage() {
                try {
                    const keyMapping = {
                        'RECOMMENDED_BOOKS': 'recommendedBooks',
                        'BOOK_SHELF_BOOKS': 'bookShelfBooks', 
                        'FLAGGED_BOOKS': 'flaggedBooks',
                        'BETH_DELETED_BOOKS': 'bethDeletedBooks',
                        'ADMIN_ALERTS': 'adminAlerts',
                        'ADMIN_PENDING_RECS': 'adminPendingRecommendations',
                        'ADMIN_APPROVED_BOOKS': 'adminApprovedBooks',
                        'BETH_NEGATIVE_FEEDBACK': 'bethNegativeFeedback'
                    };

                    Object.keys(STORAGE_KEYS).forEach(key => {
                        const data = localStorage.getItem(STORAGE_KEYS[key]);
                        if (data) {
                            const arrayName = keyMapping[key];
                            if (arrayName && appState.data[arrayName] !== undefined) {
                                appState.data[arrayName] = JSON.parse(data);
                            }
                        }
                    });
                    console.log("Data loaded from localStorage");
                } catch (error) {
                    console.warn("Failed to load from localStorage:", error);
                }
            }

            async addAlert(alert) {
                if (!appState.db || !appState.adminUserId) return null;
                
                try {
                    const collectionRef = collection(appState.db, this.getCollectionPath('admin_alerts', appState.adminUserId));
                    const docRef = await addDoc(collectionRef, alert);
                    console.log(`Added alert with ID: ${docRef.id}`);
                    return { id: docRef.id, ...alert };
                } catch (error) {
                    console.error("Failed to add alert:", error);
                    return null;
                }
            }

            async deleteAlert(docId) {
                if (!appState.db || !appState.adminUserId) return false;
                
                try {
                    const docRef = doc(appState.db, this.getCollectionPath('admin_alerts', appState.adminUserId), docId);
                    await deleteDoc(docRef);
                    console.log(`Deleted alert ${docId}`);
                    return true;
                } catch (error) {
                    console.error("Failed to delete alert:", error);
                    return false;
                }
            }
        }

        const storage = new StorageManager();

        // === API LAYER ===
        class ApiManager {
            constructor() {
                this.requestCache = new Map();
                this.requestQueue = [];
                this.isProcessingQueue = false;
            }

            async fetchWithRetry(url, options = {}, maxRetries = 3) {
                const controller = new AbortController();
                appState.activeAbortControllers.add(controller);

                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    try {
                        const response = await utils.withTimeout(
                            fetch(url, { ...options, signal: controller.signal }),
                            15000,
                            'Request timeout'
                        );
                        
                        if (response.ok) return response;
                        if (response.status >= 400 && response.status < 500) break; // Don't retry client errors
                        
                        if (attempt < maxRetries - 1) {
                            await utils.delay(Math.pow(2, attempt) * 1000); // Exponential backoff
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') throw error;
                        if (attempt === maxRetries - 1) throw error;
                        await utils.delay(Math.pow(2, attempt) * 1000);
                    } finally {
                        appState.activeAbortControllers.delete(controller);
                    }
                }
                throw new Error(`Failed after ${maxRetries} attempts`);
            }

            async fetchBookDetails(workKey, requireCover = true) {
                if (!workKey) return null;
                
                const cacheKey = `book_${workKey}_${requireCover}`;
                if (this.requestCache.has(cacheKey)) {
                    return this.requestCache.get(cacheKey);
                }

                try {
                    const response = await this.fetchWithRetry(`${CONFIG.OPEN_LIBRARY_WORK_URL}${workKey}.json`);
                    const data = await response.json();

                    const firstPublishYear = data.first_publish_year && typeof data.first_publish_year === 'number' ? data.first_publish_year : null;
                    if (firstPublishYear && firstPublishYear < CONFIG.MIN_PUBLISH_YEAR) {
                        console.log(`Skipping "${data.title}" - too old (${firstPublishYear})`);
                        return null;
                    }

                    // Enhanced description extraction from Open Library
                    let description = '';
                    if (data.description) {
                        if (typeof data.description === 'object' && data.description.value) {
                            description = data.description.value;
                        } else if (typeof data.description === 'string') {
                            description = data.description;
                        }
                    }

                    // Check for excerpts if no description
                    if (!description && data.excerpts?.length > 0) {
                        description = data.excerpts[0].excerpt || '';
                    }

                    // Check for first_sentence if still no description
                    if (!description && data.first_sentence?.length > 0) {
                        description = data.first_sentence.join(' ');
                    }

                    let authorName = 'Unknown Author';
                    if (data.authors?.length > 0 && data.authors[0].author?.key) {
                        try {
                            const authorResponse = await this.fetchWithRetry(`https://openlibrary.org${data.authors[0].author.key}.json`);
                            const authorData = await authorResponse.json();
                            authorName = authorData.name || data.by_statement || 'Unknown Author';
                        } catch {
                            authorName = data.by_statement || 'Unknown Author';
                        }
                    } else if (data.by_statement) {
                        authorName = data.by_statement;
                    }

                    const bookTitle = data.title || 'Unknown Title';

                    // If still no good description, try Google Books API as fallback
                    if (!description || description.length < 50) {
                        console.log(`Trying Google Books for better description: "${bookTitle}" by ${authorName}`);
                        const googleDescription = await this.fetchGoogleBooksDescription(bookTitle, authorName);
                        if (googleDescription && googleDescription.length > description.length) {
                            description = googleDescription;
                            console.log(`Enhanced description found via Google Books`);
                        }
                    }

                    // Smart cover image handling - TRY TO FIND A COVER FIRST
                    let imageUrl = null;
                    let hasCover = false;

                    // Check if Open Library has covers
                    if (data.covers && data.covers.length > 0) {
                        imageUrl = `${CONFIG.OPEN_LIBRARY_COVER_URL}${data.covers[0]}-M.jpg`;
                        hasCover = true;
                        console.log(`Using Open Library cover for "${bookTitle}"`);
                    } else {
                        // Search for covers using multiple methods with strict matching
                        console.log(`No Open Library cover found for "${bookTitle}", searching for alternatives...`);
                        imageUrl = await this.searchForBookCover(bookTitle, authorName, data);
                        
                        if (imageUrl) {
                            hasCover = true;
                            console.log(`Found alternative cover for "${bookTitle}"`);
                        } else {
                            console.log(`No high-confidence cover match found for "${bookTitle}"`);
                        }
                    }

                    // NOW check if cover is required AFTER we tried to find one
                    if (requireCover && !hasCover) {
                        console.log(`Skipping "${bookTitle}" - no cover available and cover required`);
                        return null;
                    }

                    // Use placeholder if no cover found
                    if (!imageUrl) {
                        imageUrl = 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover+Available';
                        console.log(`Using placeholder image for "${bookTitle}"`);
                    }

                    const result = {
                        title: bookTitle,
                        author: authorName,
                        description: description || 'No description available.',
                        imageUrl: imageUrl,
                        goodreadsUrl: `https://openlibrary.org${data.key}`,
                        rating: data.ratings_average && typeof data.ratings_average === 'number' ? data.ratings_average : null,
                        subjects: data.subjects || [],
                        source: 'Open Library Work Details',
                        first_publish_year: firstPublishYear,
                        workKey,
                        hasCover: hasCover
                    };

                    this.requestCache.set(cacheKey, result);
                    return result;
                } catch (error) {
                    console.error(`Error fetching details for ${workKey}:`, error);
                    return null;
                }
            }

            async searchForBookCover(title, author, bookData) {
                // IMPORTANT: Use strict matching to prevent wrong covers from being assigned
                // We'd rather show a placeholder than the wrong book's cover
                const searches = [
                    { name: 'Open Library Identifiers', method: () => this.searchOpenLibraryCoversByIdentifiers(bookData) },
                    { name: 'Google Books', method: () => this.searchGoogleBooksCover(title, author) },
                    { name: 'Open Library Title Search', method: () => this.searchOpenLibraryCoversByTitle(title, author) }
                ];

                // Shuffle sources for variety on repeated calls
                for (let i = searches.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [searches[i], searches[j]] = [searches[j], searches[i]];
                }

                for (const search of searches) {
                    try {
                        console.log(`Trying ${search.name} for cover of "${title}"`);
                        const coverUrl = await search.method();
                        if (coverUrl) {
                            console.log(`✅ Found cover via ${search.name} for "${title}"`);
                            return coverUrl;
                        }
                    } catch (error) {
                        console.warn(`❌ ${search.name} cover search failed for "${title}":`, error);
                    }
                }

                console.log(`❌ No high-confidence cover match found for "${title}" by ${author} - better to show placeholder than wrong cover`);
                return null;
            }

            async searchOpenLibraryCoversByIdentifiers(bookData) {
                // Try to find covers using ISBNs, OCLC, LCCN, etc.
                const identifiers = [
                    ...(bookData.isbn_10 || []),
                    ...(bookData.isbn_13 || []),
                    ...(bookData.oclc_numbers || []),
                    ...(bookData.lccn || [])
                ];

                for (const identifier of identifiers) {
                    try {
                        // Try ISBN search
                        if (identifier.length >= 10) {
                            const testUrl = `https://covers.openlibrary.org/b/isbn/${identifier}-M.jpg`;
                            const response = await this.fetchWithRetry(testUrl, { method: 'HEAD' }, 1);
                            if (response.ok) {
                                console.log(`Found cover via ISBN ${identifier}`);
                                return testUrl;
                            }
                        }

                        // Try OCLC search
                        if (identifier.length >= 8) {
                            const testUrl = `https://covers.openlibrary.org/b/oclc/${identifier}-M.jpg`;
                            const response = await this.fetchWithRetry(testUrl, { method: 'HEAD' }, 1);
                            if (response.ok) {
                                console.log(`Found cover via OCLC ${identifier}`);
                                return testUrl;
                            }
                        }
                    } catch (error) {
                        // Continue to next identifier
                        continue;
                    }
                }

                return null;
            }

            async searchGoogleBooksCover(title, author) {
                try {
                    const cleanTitle = title.replace(/[^\w\s]/g, '').trim();
                    const cleanAuthor = author.replace(/[^\w\s]/g, '').trim();
                    const query = `${cleanTitle} ${cleanAuthor}`.trim();
                    
                    if (query.length < 3) return null;

                    const response = await this.fetchWithRetry(
                        `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=5`,
                        {},
                        2
                    );

                    const data = await response.json();
                    
                    if (!data.items || data.items.length === 0) {
                        return null;
                    }

                    // Find the best match and get its cover with strict matching
                    for (const item of data.items) {
                        const volumeInfo = item.volumeInfo;
                        const googleTitle = volumeInfo.title?.toLowerCase() || '';
                        const googleAuthors = volumeInfo.authors || [];
                        
                        // More precise title matching - check for substantial overlap
                        const cleanGoogleTitle = googleTitle.replace(/[^\w\s]/g, '').trim().toLowerCase();
                        const cleanSearchTitle = cleanTitle.replace(/[^\w\s]/g, '').trim().toLowerCase();
                        
                        // Calculate title similarity (simple word overlap method)
                        const googleWords = new Set(cleanGoogleTitle.split(/\s+/).filter(w => w.length > 2));
                        const searchWords = new Set(cleanSearchTitle.split(/\s+/).filter(w => w.length > 2));
                        const intersection = new Set([...googleWords].filter(w => searchWords.has(w)));
                        const titleSimilarity = intersection.size / Math.max(googleWords.size, searchWords.size);
                        
                        const authorMatch = googleAuthors.some(gAuthor => 
                            gAuthor.toLowerCase().includes(cleanAuthor.toLowerCase()) ||
                            cleanAuthor.toLowerCase().includes(gAuthor.toLowerCase())
                        );

                        // Require both good title similarity (at least 50% word overlap) AND author match
                        if (titleSimilarity >= 0.5 && authorMatch && volumeInfo.imageLinks) {
                            console.log(`Google Books cover match: "${title}" - Title similarity: ${(titleSimilarity * 100).toFixed(0)}%`);
                            // Prefer higher resolution images
                            const imageLinks = volumeInfo.imageLinks;
                            if (imageLinks.medium) {
                                console.log(`Found Google Books cover (medium) for "${title}"`);
                                return imageLinks.medium.replace('http://', 'https://');
                            } else if (imageLinks.small) {
                                console.log(`Found Google Books cover (small) for "${title}"`);
                                return imageLinks.small.replace('http://', 'https://');
                            } else if (imageLinks.thumbnail) {
                                console.log(`Found Google Books cover (thumbnail) for "${title}"`);
                                return imageLinks.thumbnail.replace('http://', 'https://');
                            }
                        }
                    }

                    return null;
                } catch (error) {
                    console.warn('Google Books cover search failed:', error);
                    return null;
                }
            }

            async searchOpenLibraryCoversByTitle(title, author) {
                try {
                    // Search Open Library for the book and see if any editions have covers
                    const query = `${title} ${author}`.trim();
                    const searchResponse = await this.fetchWithRetry(
                        `${CONFIG.OPEN_LIBRARY_SEARCH_URL}${encodeURIComponent(query)}&limit=10`,
                        {},
                        2
                    );

                    const searchData = await searchResponse.json();
                    
                    if (!searchData.docs) return null;

                    // Look through search results for any with covers, but be more strict about matching
                    for (const doc of searchData.docs) {
                        if (doc.cover_i) {
                            // More strict matching - check both title and author similarity with word overlap
                            const docTitle = (doc.title || '').toLowerCase();
                            const docAuthors = doc.author_name || [];
                            
                            // Calculate title similarity using word overlap
                            const cleanDocTitle = docTitle.replace(/[^\w\s]/g, '').trim();
                            const cleanSearchTitle = title.toLowerCase().replace(/[^\w\s]/g, '').trim();
                            
                            const docWords = new Set(cleanDocTitle.split(/\s+/).filter(w => w.length > 2));
                            const searchWords = new Set(cleanSearchTitle.split(/\s+/).filter(w => w.length > 2));
                            const intersection = new Set([...docWords].filter(w => searchWords.has(w)));
                            const titleSimilarity = intersection.size / Math.max(docWords.size, searchWords.size);
                            
                            const authorMatch = docAuthors.some(docAuthor => 
                                docAuthor.toLowerCase().includes(author.toLowerCase()) ||
                                author.toLowerCase().includes(docAuthor.toLowerCase())
                            );
                            
                            // Require good title similarity (at least 60% word overlap) AND author match
                            if (titleSimilarity >= 0.6 && authorMatch) {
                                const testUrl = `${CONFIG.OPEN_LIBRARY_COVER_URL}${doc.cover_i}-M.jpg`;
                                try {
                                    const response = await this.fetchWithRetry(testUrl, { method: 'HEAD' }, 1);
                                    if (response.ok) {
                                        console.log(`Found cover via title search for "${title}" - Title similarity: ${(titleSimilarity * 100).toFixed(0)}%, verified both title and author match`);
                                        return testUrl;
                                    }
                                } catch (error) {
                                    continue;
                                }
                            }
                        }
                    }

                    return null;
                } catch (error) {
                    console.warn('Open Library title search failed:', error);
                    return null;
                }
            }

            async fetchGoogleBooksDescription(title, author) {
                try {
                    // Clean and format the search query
                    const cleanTitle = title.replace(/[^\w\s]/g, '').trim();
                    const cleanAuthor = author.replace(/[^\w\s]/g, '').trim();
                    const query = `${cleanTitle} ${cleanAuthor}`.trim();
                    
                    if (query.length < 3) return null;

                    const response = await this.fetchWithRetry(
                        `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=3`,
                        {},
                        2 // Fewer retries for fallback
                    );

                    const data = await response.json();
                    
                    if (!data.items || data.items.length === 0) {
                        return null;
                    }

                    // Find the best match by checking title similarity
                    for (const item of data.items) {
                        const volumeInfo = item.volumeInfo;
                        const googleTitle = volumeInfo.title?.toLowerCase() || '';
                        const googleAuthors = volumeInfo.authors || [];
                        
                        // Check if this is likely the same book
                        const titleMatch = googleTitle.includes(cleanTitle.toLowerCase()) || 
                                         cleanTitle.toLowerCase().includes(googleTitle);
                        const authorMatch = googleAuthors.some(gAuthor => 
                            gAuthor.toLowerCase().includes(cleanAuthor.toLowerCase()) ||
                            cleanAuthor.toLowerCase().includes(gAuthor.toLowerCase())
                        );

                        if ((titleMatch || authorMatch) && volumeInfo.description) {
                            let description = volumeInfo.description;
                            
                            // Clean up HTML tags if present
                            description = description.replace(/<[^>]*>/g, '');
                            
                            // Limit length to reasonable size
                            if (description.length > 1000) {
                                description = description.substring(0, 1000) + '...';
                            }
                            
                            return description;
                        }
                    }

                    return null;
                } catch (error) {
                    console.warn('Google Books description fetch failed:', error);
                    return null;
                }
            }

            async callGeminiAPI(prompt, schema = null) {
                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }]
                    };

                    if (schema) {
                        payload.generationConfig = {
                            responseMimeType: "application/json",
                            responseSchema: schema
                        };
                    }

                    const response = await this.fetchWithRetry(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${CONFIG.API_KEY}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        }
                    );

                    const result = await response.json();

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} - ${result.error?.message || 'Unknown error'}`);
                    }

                    const content = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        throw new Error('No content in API response');
                    }

                    if (schema) {
                        try {
                            const parsed = JSON.parse(content);
                            return parsed;
                        } catch (parseError) {
                            console.error('Failed to parse JSON response:', content);
                            throw new Error('Invalid JSON in API response');
                        }
                    }

                    return content;
                } catch (error) {
                    console.error('Gemini API error:', error);
                    throw error;
                }
            }

            async searchOpenLibrary(query, limit = 30) {
                try {
                    // Validate and clean the query
                    if (!query || typeof query !== 'string') {
                        throw new Error('Invalid search query');
                    }

                    // Limit query length to prevent URL issues
                    const cleanQuery = query.trim().substring(0, 200);
                    
                    if (cleanQuery.length < 2) {
                        throw new Error('Search query too short');
                    }

                    console.log(`Searching Open Library for: "${cleanQuery}"`);
                    const response = await this.fetchWithRetry(`${CONFIG.OPEN_LIBRARY_SEARCH_URL}${encodeURIComponent(cleanQuery)}&limit=${limit}`);
                    return await response.json();
                } catch (error) {
                    console.error('Open Library search error:', error);
                    throw error;
                }
            }
        }

        const api = new ApiManager();

        // === UI LAYER ===
        class UIManager {
            showMessage(text, isLoader = false, isLlmInsight = false) {
                const messageBox = utils.safeGetElement('message-box');
                const messageText = utils.safeGetElement('message-text');
                const closeButton = utils.safeGetElement('message-box-close');

                if (!messageBox || !messageText || !closeButton) return;

                messageText.innerHTML = isLoader ? `<div class="loader"></div><p class="mt-4">${text}</p>` : text;
                messageBox.classList.toggle('llm-insight', isLlmInsight);
                closeButton.style.display = isLoader ? 'none' : 'block';
                messageBox.style.display = 'block';

                if (!isLoader && !isLlmInsight) {
                    setTimeout(() => {
                        messageBox.style.display = 'none';
                    }, 5000);
                }
            }

            hideMessage() {
                const messageBox = utils.safeGetElement('message-box');
                if (messageBox) {
                    messageBox.style.display = 'none';
                    messageBox.classList.remove('llm-insight');
                }
            }

            showView(viewId) {
                const views = ['recommendations-view', 'bookshelf-view', 'beth-deleted-books-view', 'flagged-books-view', 'admin-approved-books-view', 'saved-books-view'];
                
                views.forEach(id => {
                    const element = utils.safeGetElement(id);
                    if (element) {
                        element.classList.toggle('hidden', id !== viewId);
                    }
                });

                // Update nav buttons
                document.querySelectorAll('.nav-button').forEach(button => {
                    button.classList.toggle('active', button.id === `nav-${viewId.replace('-view', '')}`);
                });

                // Refresh content
                this.refreshView(viewId);
            }

            refreshView(viewId) {
                if (!appState.uiReadyForDisplay) return;

                try {
                    switch (viewId) {
                        case 'recommendations-view':
                            this.displayRecommendedBooks();
                            break;
                        case 'bookshelf-view':
                            this.displayBookShelfBooks();
                            break;
                        case 'beth-deleted-books-view':
                            this.displayBethsDeletedBooks();
                            break;
                        case 'flagged-books-view':
                            this.displayFlaggedBooks();
                            break;
                        case 'admin-approved-books-view':
                            this.displayAdminApprovedBooks();
                            break;
                        case 'saved-books-view':
                            this.displaySavedBooks();
                            break;
                    }
                } catch (error) {
                    console.error(`Error refreshing view ${viewId}:`, error);
                }
            }

            displayRecommendedBooks() {
                const container = utils.safeGetElement('book-list');
                const noBooks = utils.safeGetElement('no-books-message');
                const heading = utils.safeGetElement('recommended-reads-heading');
                
                if (!container) return;

                // Update heading
                if (heading) {
                    const date = new Date();
                    const month = date.toLocaleString('default', { month: 'long' });
                    const year = date.getFullYear();
                    heading.textContent = `Recommended Reads (${month} ${year})`;
                }

                container.innerHTML = '';

                // Filter books not on bookshelf
                const booksToDisplay = appState.data.recommendedBooks.filter(book => 
                    !['like', 'love', 'picked', 'passed'].includes(book.userRating)
                );

                if (booksToDisplay.length === 0) {
                    if (noBooks) {
                        noBooks.classList.remove('hidden');
                        noBooks.textContent = "No books recommended yet. New recommendations will be added soon!";
                    }
                    return;
                }

                if (noBooks) noBooks.classList.add('hidden');

                booksToDisplay.forEach((book, index) => {
                    const bookCard = this.createBookCard(book, 'recommended', index);
                    container.appendChild(bookCard);
                });
            }

            displayBookShelfBooks() {
                const container = utils.safeGetElement('bookshelf-list');
                const noBooks = utils.safeGetElement('no-bookshelf-message');
                
                if (!container) return;

                container.innerHTML = '';

                if (appState.data.bookShelfBooks.length === 0) {
                    if (noBooks) noBooks.classList.remove('hidden');
                    return;
                }

                if (noBooks) noBooks.classList.add('hidden');

                appState.data.bookShelfBooks.forEach((book, index) => {
                    const bookCard = this.createBookCard(book, 'bookshelf', index);
                    container.appendChild(bookCard);
                });
            }

            displayBethsDeletedBooks() {
                const container = utils.safeGetElement('beth-deleted-books-list');
                const noBooks = utils.safeGetElement('no-beth-deleted-books-message');
                
                if (!container || !noBooks) return;

                container.innerHTML = '';

                if (appState.data.bethDeletedBooks.length === 0) {
                    noBooks.classList.remove('hidden');
                    noBooks.textContent = "No deleted books yet.";
                    return;
                }

                noBooks.classList.add('hidden');

                appState.data.bethDeletedBooks.forEach((book, index) => {
                    const bookCard = this.createBookCard(book, 'deleted', index);
                    container.appendChild(bookCard);
                });
            }

            displayFlaggedBooks() {
                const container = utils.safeGetElement('flagged-books-list');
                const noBooks = utils.safeGetElement('no-flagged-books-message');
                
                if (!container || !noBooks) return;

                container.innerHTML = '';

                if (appState.data.flaggedBooks.length === 0) {
                    noBooks.classList.remove('hidden');
                    noBooks.textContent = "No flagged books yet.";
                    return;
                }

                noBooks.classList.add('hidden');

                appState.data.flaggedBooks.forEach((book, index) => {
                    const bookCard = this.createBookCard(book, 'flagged', index);
                    container.appendChild(bookCard);
                });
            }

            displayAdminApprovedBooks() {
                const container = utils.safeGetElement('admin-approved-books-list');
                const noBooks = utils.safeGetElement('no-admin-approved-books-message');
                
                if (!container || !noBooks) return;

                container.innerHTML = '';

                // Only show admin-approved books (not user-saved books)
                const adminApprovedOnly = appState.data.adminApprovedBooks.filter(book => !book.savedByUser);

                if (adminApprovedOnly.length === 0) {
                    noBooks.classList.remove('hidden');
                    noBooks.textContent = "No approved books awaiting placement.";
                    return;
                }

                noBooks.classList.add('hidden');

                adminApprovedOnly.forEach(book => {
                    const item = this.createAdminItem(book, 'approved');
                    container.appendChild(item);
                });
            }

            displaySavedBooks() {
                const container = utils.safeGetElement('saved-books-list');
                const noBooks = utils.safeGetElement('no-saved-books-message');
                
                if (!container || !noBooks) return;

                container.innerHTML = '';

                // Filter admin approved books that were saved by user (not by admin)
                const userSavedBooks = appState.data.adminApprovedBooks.filter(book => book.savedByUser === true);

                if (userSavedBooks.length === 0) {
                    noBooks.classList.remove('hidden');
                    noBooks.textContent = "No books saved for later yet.";
                    return;
                }

                noBooks.classList.add('hidden');

                userSavedBooks.forEach((book, index) => {
                    const bookCard = this.createBookCard(book, 'saved', index);
                    container.appendChild(bookCard);
                });
            }

            displayAdminPendingRecommendations() {
                const container = utils.safeGetElement('admin-pending-recs-container');
                const list = utils.safeGetElement('admin-pending-recs-list');
                const noRecs = utils.safeGetElement('no-admin-pending-recs-message');

                if (!container || !list || !noRecs) return;

                list.innerHTML = '';

                if (appState.data.adminPendingRecommendations.length === 0) {
                    container.classList.add('hidden');
                    noRecs.classList.remove('hidden');
                    noRecs.textContent = "No recommendations awaiting approval.";
                    return;
                }

                container.classList.remove('hidden');
                noRecs.classList.add('hidden');

                appState.data.adminPendingRecommendations.forEach(book => {
                    const item = this.createAdminItem(book, 'pending');
                    list.appendChild(item);
                });
            }

            displayAdminAlerts() {
                const container = utils.safeGetElement('admin-alerts-container');
                const list = utils.safeGetElement('admin-alerts-list');
                const noAlerts = utils.safeGetElement('no-admin-alerts-message');

                if (!container || !list || !noAlerts) return;

                list.innerHTML = '';

                if (appState.data.adminAlerts.length === 0) {
                    container.classList.add('hidden');
                    noAlerts.classList.remove('hidden');
                    return;
                }

                container.classList.remove('hidden');
                noAlerts.classList.add('hidden');

                appState.data.adminAlerts.forEach(alert => {
                    const item = document.createElement('div');
                    item.className = 'admin-alert-item';
                    item.innerHTML = `
                        <span>${utils.escapeHtml(alert.message)} <span class="text-gray-500 text-xs ml-2">(${utils.escapeHtml(alert.timestamp)})</span></span>
                        <button class="dismiss-button dismiss-admin-alert-btn" data-id="${utils.escapeJs(alert.id)}">Dismiss</button>
                    `;
                    list.appendChild(item);
                });
            }

            createBookCard(book, type, index = 0) {
                const card = document.createElement('div');
                const isSmall = ['bookshelf', 'deleted', 'flagged', 'saved'].includes(type);
                card.className = `book-card ${isSmall ? 'bookshelf-card-small' : ''} bg-white rounded-lg shadow-md overflow-hidden flex flex-col`;
                card.style.animationDelay = `${index * (isSmall ? 0.05 : 0.1)}s`;

                const description = book.description || 'No description available.';
                const adminPanel = utils.safeGetElement('admin-search-panel');
                const isAdminMode = adminPanel && !adminPanel.classList.contains('hidden');
                
                let adminActionsHtml = '';
                let userActionsHtml = '';
                let statusHtml = '';

                // Build content based on type
                switch (type) {
                    case 'recommended':
                        userActionsHtml = `
                            <button class="action-button w-full mb-4 pick-book-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Click to Pick!</button>
                            <button class="action-button insight-btn w-full mb-4 get-insight-btn" data-book-json="${utils.escapeHtml(JSON.stringify(book))}">✨ Why for Me?</button>
                            <button class="action-button pass-btn w-full mb-2 pass-book-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Pass</button>
                            <button class="action-button save-later-btn w-full save-for-later-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Save for Later</button>
                        `;
                        if (isAdminMode) {
                            adminActionsHtml = `
                                <button class="remove-admin-button" data-workkey="${utils.escapeHtml(book.workKey)}">Remove from Club</button>
                                <button class="action-button w-full mt-2 move-to-approved-btn" data-workkey="${utils.escapeHtml(book.workKey)}" style="background-color: #3b82f6;">Move to Admin Approved</button>
                                <button class="action-button red-flag-btn w-full mt-2" data-workkey="${utils.escapeHtml(book.workKey)}" data-author="${utils.escapeHtml(book.author)}">🚩 Red Flag</button>
                            `;
                        }
                        break;

                    case 'bookshelf':
                        statusHtml = this.getBookshelfStatus(book);
                        break;

                    case 'deleted':
                        userActionsHtml = `
                            <button class="action-button w-full mt-4 restore-beth-deleted-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Restore to Bookshelf</button>
                        `;
                        break;

                    case 'flagged':
                        if (book.flaggedReason) {
                            statusHtml = `<p class="text-red-500 text-sm mt-2">Reason: ${utils.escapeHtml(book.flaggedReason)}</p>`;
                        }
                        userActionsHtml = `
                            <button class="action-button w-full mt-4 restore-flagged-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Restore to Recommendations</button>
                        `;
                        break;

                    case 'saved':
                        userActionsHtml = `
                            <button class="action-button w-full mt-4 pick-and-move-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Pick and Move to Bookshelf</button>
                        `;
                        break;
                }

                card.innerHTML = `
                    <a href="${utils.escapeJs(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                        <img src="${utils.escapeJs(book.imageUrl)}" alt="${utils.escapeJs(book.title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover+Available';">
                        <div class="p-6 flex flex-col flex-grow">
                            <h3 class="text-xl font-semibold text-gray-900 mb-2">${utils.escapeJs(book.title)}</h3>
                            <p class="text-gray-600 text-sm mb-2">by ${utils.escapeJs(book.author)}</p>
                            ${book.rating ? utils.getStarRatingHtml(book.rating) : ''}
                            <p class="text-gray-700 text-base book-description flex-grow">${utils.escapeJs(description)}</p>
                            ${statusHtml}
                        </div>
                    </a>
                    <div class="p-6 pt-0 flex flex-col items-center">
                        ${userActionsHtml}
                        ${adminActionsHtml}
                    </div>
                `;

                return card;
            }

            getBookshelfStatus(book) {
                let statusText = '';
                let reviewButtons = '';

                switch (book.userRating) {
                    case 'picked':
                        statusText = 'Picked to read!';
                        reviewButtons = `
                            <p class="text-gray-600 text-sm mb-2">After reading, how was it?</p>
                            <div class="review-buttons" data-book-workkey="${utils.escapeHtml(book.workKey)}">
                                <button class="review-button update-rating-btn" data-rating="mid">Mid</button>
                                <button class="review-button update-rating-btn" data-rating="like">Like</button>
                                <button class="review-button update-rating-btn" data-rating="love">Love</button>
                            </div>
                        `;
                        break;
                    case 'mid':
                        statusText = 'You thought this was Mid.';
                        reviewButtons = this.createReviewButtons(book.workKey, 'mid');
                        break;
                    case 'like':
                        statusText = 'You Liked this!';
                        reviewButtons = this.createReviewButtons(book.workKey, 'like');
                        break;
                    case 'love':
                        statusText = 'You Loved this!';
                        reviewButtons = this.createReviewButtons(book.workKey, 'love');
                        break;
                }

                return `
                    <p class="text-gray-700 text-lg font-semibold mt-2">${statusText}</p>
                    ${reviewButtons}
                    <button class="text-red-500 hover:text-red-700 text-sm font-medium mt-4 remove-from-bookshelf-btn" data-workkey="${utils.escapeHtml(book.workKey)}">Remove from Bookshelf</button>
                `;
            }

            createReviewButtons(workKey, selected) {
                const ratings = ['mid', 'like', 'love'];
                const buttons = ratings.map(rating => {
                    const selectedClass = rating === selected ? `selected-${rating}` : '';
                    return `<button class="review-button ${selectedClass} update-rating-btn" data-rating="${rating}">${rating.charAt(0).toUpperCase() + rating.slice(1)}</button>`;
                }).join('');

                return `
                    <p class="text-gray-600 text-sm mb-2">Change your rating?</p>
                    <div class="review-buttons" data-book-workkey="${utils.escapeHtml(workKey)}">
                        ${buttons}
                    </div>
                `;
            }

            createAdminItem(book, type) {
                const item = document.createElement('div');
                item.className = type === 'pending' ? 'admin-pending-rec-item' : 'admin-approved-book-item';

                const descriptionHtml = book.description ? `<p class="text-gray-700 text-sm mt-2 mb-2">${utils.escapeHtml(book.description)}</p>` : '';
                const prosHtml = book.pros?.length ? `
                    <h4 class="font-semibold text-green-700 mt-2">Pros:</h4>
                    <ul class="list-disc list-inside text-left text-sm">
                        ${book.pros.map(p => `<li>${utils.escapeHtml(p)}</li>`).join('')}
                    </ul>
                ` : '';
                const consHtml = book.cons?.length ? `
                    <h4 class="font-semibold text-red-700 mt-2">Cons:</h4>
                    <ul class="list-disc list-inside text-left text-sm">
                        ${book.cons.map(c => `<li>${utils.escapeHtml(c)}</li>`).join('')}
                    </ul>
                ` : '';
                const linkHtml = book.goodreadsUrl ? `
                    <a href="${utils.escapeJs(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline text-sm mt-2 block">View on Open Library</a>
                ` : '';
                const yearHtml = book.first_publish_year ? `<p class="text-gray-600 text-xs mt-1">Published: ${utils.escapeHtml(book.first_publish_year)}</p>` : '';
                
                let buttonsHtml = '';
                if (type === 'pending') {
                    buttonsHtml = `
                        <button class="approve-button approve-for-beth-btn" data-book-json="${utils.escapeHtml(JSON.stringify(book))}">Approve for Beth</button>
                        <button class="action-button pass-btn skip-pending-btn" data-workkey="${utils.escapeJs(book.workKey)}">Skip</button>
                        <button class="action-button red-flag-btn red-flag-pending-btn" data-workkey="${utils.escapeJs(book.workKey)}" data-author="${utils.escapeJs(book.author)}">🚩 Red Flag</button>
                    `;
                } else {
                    buttonsHtml = `
                        <button class="move-to-recs-button move-to-beths-recs-btn" data-book-json="${utils.escapeHtml(JSON.stringify(book))}">Move to Beth's Recommendations</button>
                        <button class="action-button red-flag-btn remove-from-approved-btn" data-workkey="${utils.escapeJs(book.workKey)}">Remove from Approved</button>
                    `;
                }

                item.innerHTML = `
                    <div class="book-info">
                        "${utils.escapeHtml(book.title)}" by ${utils.escapeHtml(book.author)} (Score: ${book.score || 'N/A'}/100)
                        ${yearHtml}
                    </div>
                    ${descriptionHtml}
                    ${prosHtml}
                    ${consHtml}
                    ${linkHtml}
                    <div class="flex gap-2 mt-4">
                        ${buttonsHtml}
                    </div>
                `;

                return item;
            }

            setAdminUIVisibility(showAdmin) {
                const elements = ['admin-search-panel', 'nav-flagged-books', 'nav-admin-approved-books'];
                elements.forEach(id => {
                    const element = utils.safeGetElement(id);
                    if (element) element.classList.toggle('hidden', !showAdmin);
                });

                // Always show deleted books tab to both user and admin
                const deletedBooksTab = utils.safeGetElement('nav-beth-deleted-books');
                if (deletedBooksTab) deletedBooksTab.classList.remove('hidden');

                // Clear admin inputs
                ['search-input', 'manual-add-url-input', 'evaluate-book-url-input'].forEach(id => {
                    const input = utils.safeGetElement(id);
                    if (input) input.value = '';
                });

                const searchResults = utils.safeGetElement('search-results');
                if (searchResults) searchResults.innerHTML = '';

                // Refresh displays to show/hide admin buttons
                if (appState.uiReadyForDisplay) {
                    this.refreshAllDisplays();
                }
            }

            displaySearchResults(results) {
                const container = utils.safeGetElement('search-results');
                if (!container) return;

                container.innerHTML = '';

                results.slice(0, 10).forEach(book => {
                    const card = document.createElement('div');
                    card.className = 'book-card bg-white rounded-lg shadow-md overflow-hidden flex flex-col';

                    const sourceTag = book.source ? `<span class="source-tag">${book.source}</span>` : '';

                    card.innerHTML = `
                        <a href="${utils.escapeJs(book.goodreadsUrl)}" target="_blank" rel="noopener noreferrer" class="book-link">
                            <img src="${utils.escapeJs(book.imageUrl)}" alt="${utils.escapeJs(book.title)} cover" class="book-image" onerror="this.onerror=null;this.src='https://placehold.co/400x600/CCCCCC/666666?text=No+Cover+Available';">
                            <div class="p-6 flex flex-col flex-grow">
                                <h3 class="text-xl font-semibold text-gray-900 mb-2">${utils.escapeJs(book.title)}</h3>
                                <p class="text-gray-600 text-sm mb-2">by ${utils.escapeJs(book.author)}</p>
                                <p class="text-gray-600 text-xs mb-4">First Published: ${utils.escapeJs(book.first_publish_year || 'N/A')}</p>
                                <p class="text-gray-700 text-base book-description flex-grow">${utils.escapeJs(book.description || 'No description available.')}</p>
                                ${sourceTag}
                            </div>
                        </a>
                        <div class="p-6 pt-0">
                            <button class="action-button w-full add-to-curated-list-btn" data-book-json="${utils.escapeHtml(JSON.stringify(book))}">Add to Beth's Club</button>
                        </div>
                    `;
                    container.appendChild(card);
                });
            }

            refreshAllDisplays() {
                if (!appState.uiReadyForDisplay) return;

                try {
                    this.displayRecommendedBooks();
                    this.displayBookShelfBooks();
                    this.displayBethsDeletedBooks();
                    this.displayFlaggedBooks();
                    this.displayAdminAlerts();
                    this.displayAdminPendingRecommendations();
                    this.displayAdminApprovedBooks();
                    this.displaySavedBooks();
                } catch (error) {
                    console.error('Error refreshing displays:', error);
                }
            }
        }

        const ui = new UIManager();

        // === BUSINESS LOGIC ===
        class BookManager {
            calculateBookScore(book, lovedBooks, likedBooks, selectedAuthors = new Set()) {
                let score = 20; // Base score

                const title = (book.title || '').toLowerCase();
                const description = (book.description || '').toLowerCase();
                const author = (book.author || '').toLowerCase();
                const subjects = (book.subjects || []).map(s => s.toLowerCase());

                // Genre alignment
                CONFIG.BETH_GENRE_KEYWORDS.forEach(keyword => {
                    if (title.includes(keyword) || description.includes(keyword) || 
                        subjects.some(s => s.includes(keyword))) {
                        score += 10;
                    }
                });

                // Author and subject affinity
                const lovedAuthors = new Set(lovedBooks.map(b => b.author.toLowerCase()));
                const likedAuthors = new Set(likedBooks.map(b => b.author.toLowerCase()));
                const lovedSubjects = new Set(lovedBooks.flatMap(b => (b.subjects || []).map(s => s.toLowerCase())));
                const likedSubjects = new Set(likedBooks.flatMap(b => (b.subjects || []).map(s => s.toLowerCase())));

                if (lovedAuthors.has(author)) score += 25;
                else if (likedAuthors.has(author)) score += 15;

                subjects.forEach(subject => {
                    if (lovedSubjects.has(subject)) score += 7;
                    else if (likedSubjects.has(subject)) score += 3;
                });

                // Rating bonus
                if (book.rating) score += book.rating * 3;

                // Source bonus
                if (book.source?.includes('AI')) score += 10;
                else if (book.source?.includes('Bookshelf')) score += 8;
                else if (book.source?.includes('Trending')) score += 5;

                // Author diversity penalty
                const allBookshelfAuthors = new Set(appState.data.bookShelfBooks.map(b => b.author.toLowerCase()));
                if (allBookshelfAuthors.has(author)) score -= 25;
                if (selectedAuthors.has(author)) score -= 20;

                return Math.max(0, Math.min(100, score));
            }

            async getAIEvaluation(book) {
                const { title, author, description, subjects } = book;
                const favoriteGenres = CONFIG.BETH_GENRE_KEYWORDS.join(', ');
                const lovedBooks = appState.data.bookShelfBooks.filter(b => b.userRating === 'love');
                const likedBooks = appState.data.bookShelfBooks.filter(b => b.userRating === 'like');

                let prompt = `You are an AI assistant evaluating a book for Beth's book club.
                Beth enjoys the following genres: ${favoriteGenres}.`;
                
                if (lovedBooks.length > 0) {
                    prompt += `\nShe has LOVED these books: ${lovedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
                }
                if (likedBooks.length > 0) {
                    prompt += `\nShe has LIKED these books: ${likedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
                }
                
                prompt += `\nHere is the book to evaluate:
                Title: "${title}"
                Author: ${author}`;
                
                if (description) prompt += `\nDescription: ${description}`;
                if (subjects?.length) prompt += `\nSubjects/Themes: ${subjects.join(', ')}`;
                
                prompt += `\nPlease provide a critical evaluation of this book's suitability for Beth. Include:
                1. A "Pros" list (why she might like it, connecting to her preferences).
                2. A "Cons" list (potential reasons she might not like it).
                3. A concise "Summary" (2-3 sentences).
                Provide your response as a JSON object with properties: "pros" (array of strings), "cons" (array of strings), "summary" (string).`;

                const schema = {
                    type: "OBJECT",
                    properties: {
                        "pros": { "type": "ARRAY", "items": { "type": "STRING" } },
                        "cons": { "type": "ARRAY", "items": { "type": "STRING" } },
                        "summary": { "type": "STRING" }
                    },
                    "propertyOrdering": ["pros", "cons", "summary"]
                };

                try {
                    return await api.callGeminiAPI(prompt, schema);
                } catch (error) {
                    console.error('AI evaluation failed:', error);
                    return {
                        pros: ['Matches your preferred genres'],
                        cons: ['Limited information available'],
                        summary: 'This book appears to match your reading preferences based on genre and themes.'
                    };
                }
            }

            async getPersonalizedInsight(book) {
                const { title, author, description, subjects } = book;
                const favoriteGenres = CONFIG.BETH_GENRE_KEYWORDS.join(', ');
                const lovedBooks = appState.data.bookShelfBooks.filter(b => b.userRating === 'love').map(b => b.title);
                const likedBooks = appState.data.bookShelfBooks.filter(b => b.userRating === 'like').map(b => b.title);

                let prompt = `You are an AI assistant explaining to Beth why a specific book is recommended for her.
                Speak directly to Beth using "you" and "your".
                
                Beth's favorite genres are: ${favoriteGenres}.`;
                
                if (lovedBooks.length > 0) {
                    prompt += `\nYou have "loved" the following books: ${lovedBooks.join(', ')}.`;
                }
                if (likedBooks.length > 0) {
                    prompt += `\nYou have "liked" the following books: ${likedBooks.join(', ')}.`;
                }
                
                prompt += `\nHere is the book in question:
                Title: "${title}"
                Author: ${author}`;
                
                if (description) prompt += `\nDescription: ${description}`;
                if (subjects?.length) prompt += `\nSubjects/Themes: ${subjects.join(', ')}`;
                
                prompt += `\nExplain in a friendly, concise, and compelling way why this book is a good recommendation for Beth, speaking directly to her using "you" and "your". Connect it to her stated preferences and past liked/loved books. Focus on aspects like genre, themes, author style (if applicable), and overall appeal for someone with her tastes. Keep it to 2-3 sentences. Your response should start directly with the explanation and contain no introductory phrases, conversational filler, or repetition of the book title.`;

                try {
                    const response = await api.callGeminiAPI(prompt);
                    // Clean up response to remove any remaining impersonal language
                    return response
                        .replace(/^(Sure, here's why this book is a good recommendation for Beth:|Here's why this book is a good recommendation for Beth:|This book is a good recommendation for Beth because|This book is recommended for Beth because|Here's why this book is recommended for Beth:)\s*/i, '')
                        .replace(new RegExp(`^\\*\\*Why "${title}" for Beth\\?\\*\\*\\n\\n`, 'i'), '')
                        .replace(/^(This book is recommended for you because|You might enjoy this book because|This book aligns with your preferences because|This book is a great fit for you because)\s*/i, '')
                        .replace(/\b(we|us|our)\b/gi, (match) => {
                            switch(match.toLowerCase()) {
                                case 'we': return 'you';
                                case 'us': return 'you';
                                case 'our': return 'your';
                                default: return match;
                            }
                        });
                } catch (error) {
                    console.error('Insight generation failed:', error);
                    throw error;
                }
            }

            async generateRecommendations() {
                const loader = utils.safeGetElement('search-loader');
                const message = utils.safeGetElement('search-message');
                const searchResults = utils.safeGetElement('search-results');

                if (searchResults) searchResults.innerHTML = '';
                if (message) message.classList.add('hidden');
                if (loader) loader.style.display = 'block';
                
                ui.showMessage('Generating recommendations... This might take a moment.', true, false);

                try {
                    await this.sendAlert('recommendations_generation_started');

                    const TARGET_BOOKS = 3; // Minimum viable books needed
                    const MAX_ATTEMPTS = 5; // Maximum generation attempts to prevent infinite loops
                    let totalBooksAdded = 0;
                    let attempt = 1;

                    while (totalBooksAdded < TARGET_BOOKS && attempt <= MAX_ATTEMPTS) {
                        ui.showMessage(`Generating recommendations... Attempt ${attempt}/${MAX_ATTEMPTS}. Found ${totalBooksAdded} viable books so far.`, true, false);
                        
                        console.log(`Generation attempt ${attempt}: Need ${TARGET_BOOKS - totalBooksAdded} more books`);

                        const candidates = await this.collectCandidates();
                        
                        if (candidates.length === 0) {
                            console.warn(`Attempt ${attempt}: No candidates found`);
                            attempt++;
                            continue;
                        }

                        const recommendations = await this.processRecommendations(candidates);
                        
                        if (recommendations.length === 0) {
                            console.warn(`Attempt ${attempt}: No viable recommendations from ${candidates.length} candidates`);
                            attempt++;
                            continue;
                        }

                        // Add books to pending that don't already exist anywhere
                        let booksAddedThisRound = 0;
                        for (const book of recommendations.slice(0, CONFIG.RECOMMENDATION_CONFIG.TARGET_BOOKS)) {
                            if (!this.isExistingBook(book.workKey)) {
                                await storage.saveToFirestore(book, 'admin_pending_recs', appState.adminUserId);
                                booksAddedThisRound++;
                                totalBooksAdded++;
                                console.log(`Added: "${book.title}" by ${book.author} (Score: ${book.score})`);
                                
                                // Break if we've reached our target
                                if (totalBooksAdded >= TARGET_BOOKS) {
                                    break;
                                }
                            }
                        }

                        console.log(`Attempt ${attempt}: Added ${booksAddedThisRound} books (Total: ${totalBooksAdded})`);
                        
                        // If we didn't add any books this round, increment attempt
                        if (booksAddedThisRound === 0) {
                            console.warn(`Attempt ${attempt}: No new books added (all were duplicates)`);
                        }
                        
                        attempt++;
                        
                        // Add a small delay between attempts to be respectful to APIs
                        if (totalBooksAdded < TARGET_BOOKS && attempt <= MAX_ATTEMPTS) {
                            await utils.delay(1000);
                        }
                    }

                    if (loader) loader.style.display = 'none';

                    // Provide feedback based on results
                    if (totalBooksAdded >= TARGET_BOOKS) {
                        ui.showMessage(`🎉 Success! Generated ${totalBooksAdded} viable book recommendations after ${attempt - 1} attempts. Check the admin panel to review and approve them for Beth.`, false, false);
                    } else if (totalBooksAdded > 0) {
                        ui.showMessage(`⚠️ Generated ${totalBooksAdded} recommendations (wanted ${TARGET_BOOKS}) after ${MAX_ATTEMPTS} attempts. This might indicate limited new options available. Check the admin panel to review what was found.`, false, false);
                    } else {
                        ui.showMessage(`❌ Could not find any new viable recommendations after ${MAX_ATTEMPTS} attempts. This might mean Beth needs to rate more books or all suitable books have already been considered.`, false, false);
                    }

                } catch (error) {
                    console.error('Recommendation generation failed:', error);
                    if (loader) loader.style.display = 'none';
                    ui.showMessage('Failed to generate recommendations due to API issues. Please try again later.', false, false);
                }
            }

            async collectCandidates() {
                const sources = [
                    () => this.getBookshelfBasedRecommendations(),
                    () => this.getAIPoweredRecommendations(),
                    () => this.getTrendingRecommendations(),
                    () => this.getGenreSpecificRecommendations()
                ];

                // Shuffle sources for variety on repeated calls
                for (let i = sources.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [sources[i], sources[j]] = [sources[j], sources[i]];
                }

                const results = await Promise.allSettled(sources.map(fn => fn()));
                
                const candidates = results.reduce((acc, result, index) => {
                    if (result.status === 'fulfilled' && Array.isArray(result.value)) {
                        acc = acc.concat(result.value);
                        console.log(`Source ${index} found: ${result.value.length} candidates`);
                    } else {
                        console.warn(`Source ${index} failed:`, result.reason);
                    }
                    return acc;
                }, []);

                // Deduplicate and filter out invalid candidates
                const uniqueCandidates = [];
                const seen = new Set();
                for (const candidate of candidates) {
                    if (candidate?.workKey && 
                        candidate?.title && 
                        candidate?.author && 
                        !seen.has(candidate.workKey)) {
                        uniqueCandidates.push(candidate);
                        seen.add(candidate.workKey);
                    }
                }

                // Shuffle candidates for variety
                for (let i = uniqueCandidates.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [uniqueCandidates[i], uniqueCandidates[j]] = [uniqueCandidates[j], uniqueCandidates[i]];
                }

                console.log(`Collected ${uniqueCandidates.length} unique valid candidates`);
                return uniqueCandidates;
            }

            async processRecommendations(candidates) {
                const recommendations = [];
                const selectedAuthors = new Set();
                const lovedBooks = appState.data.bookShelfBooks.filter(book => book.userRating === 'love');
                const likedBooks = appState.data.bookShelfBooks.filter(book => book.userRating === 'like');
                
                let apiCallCount = 0;
                const maxApiCalls = CONFIG.RECOMMENDATION_CONFIG.MAX_API_CALLS;

                // Shuffle for variety
                for (let i = candidates.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
                }

                for (const candidate of candidates) {
                    if (recommendations.length >= CONFIG.RECOMMENDATION_CONFIG.TARGET_BOOKS) break;
                    if (apiCallCount >= maxApiCalls) break;
                    if (!candidate?.workKey) continue;
                    if (this.isExistingBook(candidate.workKey)) continue;

                    try {
                        if (apiCallCount > 0) {
                            await utils.delay(CONFIG.RECOMMENDATION_CONFIG.API_DELAY_MS);
                        }

                        const bookDetails = await api.fetchBookDetails(candidate.workKey); // Keep default requireCover = true for automated recommendations
                        apiCallCount++;

                        if (bookDetails && !this.isExistingBook(bookDetails.workKey)) {
                            const score = this.calculateBookScore(bookDetails, lovedBooks, likedBooks, selectedAuthors);
                            
                            if (score >= CONFIG.RECOMMENDATION_CONFIG.MIN_SCORE_THRESHOLD) {
                                try {
                                    const evaluation = await this.getAIEvaluation(bookDetails);
                                    apiCallCount++;

                                    recommendations.push({
                                        ...bookDetails,
                                        score,
                                        pros: evaluation.pros,
                                        cons: evaluation.cons,
                                        summary: evaluation.summary
                                    });

                                    selectedAuthors.add(bookDetails.author.toLowerCase());
                                    console.log(`Added "${bookDetails.title}" (Score: ${score}) - Cover: ${bookDetails.hasCover ? 'Found' : 'Placeholder'}`);
                                } catch (evaluationError) {
                                    console.warn('Evaluation failed for:', bookDetails.title, evaluationError);
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Failed to process candidate:`, error);
                    }
                }

                return recommendations.sort((a, b) => b.score - a.score);
            }

            async getBookshelfBasedRecommendations() {
                const lovedBooks = appState.data.bookShelfBooks.filter(book => book.userRating === 'love');
                const likedBooks = appState.data.bookShelfBooks.filter(book => book.userRating === 'like');

                if (lovedBooks.length === 0 && likedBooks.length === 0) return [];

                const queries = new Set();
                lovedBooks.concat(likedBooks).forEach(book => {
                    if (book.author) {
                        queries.add(book.author.split(',')[0].trim());
                    }
                    if (book.subjects?.length) {
                        book.subjects.slice(0, 2).forEach(subject => {
                            queries.add(subject.trim());
                        });
                    }
                });

                if (queries.size === 0) {
                    CONFIG.BETH_GENRE_KEYWORDS.forEach(genre => queries.add(genre));
                }

                const candidates = [];
                for (const query of Array.from(queries)) {
                    try {
                        const data = await api.searchOpenLibrary(`${query} AND language:eng`, 30);
                        candidates.push(...this.processSearchResults(data, 'Based on Bookshelf'));
                    } catch (error) {
                        console.warn(`Bookshelf search failed for "${query}":`, error);
                    }
                }

                return candidates;
            }

            async getAIPoweredRecommendations() {
                const lovedBooks = appState.data.bookShelfBooks.filter(book => book.userRating === 'love');
                const likedBooks = appState.data.bookShelfBooks.filter(book => book.userRating === 'like');

                // Add some randomness to the prompt for variety on repeated calls
                const emphasisPhrases = [
                    'prioritize lesser-known gems',
                    'include both popular and underrated titles',
                    'focus on diverse authors within the genre',
                    'emphasize recent publications',
                    'include award-winning books',
                    'prioritize highly-rated books'
                ];
                const randomEmphasis = emphasisPhrases[Math.floor(Math.random() * emphasisPhrases.length)];

                let prompt = `You are a book recommendation engine for Beth, a reader who loves ${CONFIG.BETH_GENRE_KEYWORDS.join(', ')}.

                CRUCIAL REQUIREMENTS:
                - Recommend 8-12 books
                - Focus on books published from 2000 to 2024
                - Prioritize authors Beth has NOT read yet
                - Include both established and emerging authors
                - ${randomEmphasis}`;

                if (lovedBooks.length > 0) {
                    prompt += `\n\nBeth has LOVED: ${lovedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
                }
                if (likedBooks.length > 0) {
                    prompt += `\n\nBeth has LIKED: ${likedBooks.map(b => `"${b.title}" by ${b.author}`).join('; ')}.`;
                }

                prompt += `\n\nAVOID COMPLETELY:
                - Fantasy, magic, supernatural themes
                - Romance as primary genre
                - Self-help, memoirs
                - Historical fiction before 1900

                IMPORTANT: Respond with ONLY a valid JSON array. Each book must have exactly two properties: "title" and "author". Do not include any explanations, commentary, or additional text outside the JSON.

                Example format:
                [{"title": "Gone Girl", "author": "Gillian Flynn"}, {"title": "The Girl with the Dragon Tattoo", "author": "Stieg Larsson"}]`;

                const schema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "title": { "type": "STRING" },
                            "author": { "type": "STRING" }
                        },
                        required: ["title", "author"]
                    }
                };

                try {
                    const recommendations = await api.callGeminiAPI(prompt, schema);
                    
                    // Validate that we got an array
                    if (!Array.isArray(recommendations)) {
                        console.warn('AI did not return an array, falling back to empty recommendations');
                        return [];
                    }

                    const candidates = [];

                    for (const rec of recommendations) {
                        // Validate each recommendation has the required properties
                        if (!rec.title || !rec.author || typeof rec.title !== 'string' || typeof rec.author !== 'string') {
                            console.warn('Invalid recommendation format:', rec);
                            continue;
                        }

                        try {
                            // Clean and limit the search query length
                            const cleanTitle = rec.title.trim().substring(0, 100);
                            const cleanAuthor = rec.author.trim().substring(0, 50);
                            const searchQuery = `${cleanTitle} ${cleanAuthor}`.trim();
                            
                            // Skip if the search query is too short or invalid
                            if (searchQuery.length < 3) {
                                console.warn('Search query too short:', searchQuery);
                                continue;
                            }

                            console.log(`AI searching for: "${searchQuery}"`);
                            const searchData = await api.searchOpenLibrary(searchQuery, 1);
                            const processed = this.processSearchResults(searchData, 'AI Recommendation');
                            candidates.push(...processed);
                            
                            // Add a small delay between searches to be respectful
                            await utils.delay(200);
                        } catch (error) {
                            console.warn(`AI search failed for "${rec.title}" by ${rec.author}:`, error);
                        }
                    }

                    console.log(`AI recommendations found ${candidates.length} candidates`);
                    return candidates;
                } catch (error) {
                    console.error('AI recommendations failed:', error);
                    return [];
                }
            }

            async getTrendingRecommendations() {
                try {
                    const data = await api.searchOpenLibrary('trending_score_hourly_sum:[1 TO *] language:eng&sort=trending', 30);
                    return this.processSearchResults(data, 'Trending');
                } catch (error) {
                    console.error('Trending recommendations failed:', error);
                    return [];
                }
            }

            async getGenreSpecificRecommendations() {
                const searchTerms = [
                    'psychological thriller 2000..2024',
                    'murder mystery contemporary',
                    'true crime narrative 2005..2024',
                    'domestic thriller 2010..2024',
                    'crime fiction 2015..2024',
                    'suspense novel 2020..2024',
                    'detective fiction modern',
                    'thriller bestseller 2018..2024',
                    'mystery novel award winning',
                    'crime thriller new',
                    'psychological suspense 2019..2024',
                    'murder investigation fiction'
                ];

                // Shuffle search terms for variety on repeated calls
                const shuffledTerms = [...searchTerms];
                for (let i = shuffledTerms.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledTerms[i], shuffledTerms[j]] = [shuffledTerms[j], shuffledTerms[i]];
                }

                const candidates = [];
                // Use a random subset of terms each time to get variety
                const termsToUse = shuffledTerms.slice(0, 6);
                
                for (const term of termsToUse) {
                    try {
                        const data = await api.searchOpenLibrary(term, 20);
                        candidates.push(...this.processSearchResults(data, 'Genre-Specific'));
                        // Add small delay between searches
                        await utils.delay(100);
                    } catch (error) {
                        console.warn(`Genre search failed for "${term}":`, error);
                    }
                }

                return candidates;
            }

            processSearchResults(data, source) {
                if (!data.docs) return [];

                return data.docs
                    .filter(doc => {
                        const workKeyMatch = doc.key?.match(/\/works\/(OL\d+W)/);
                        const firstPublishYear = doc.first_publish_year && typeof doc.first_publish_year === 'number' ? doc.first_publish_year : null;
                        return doc.key && (doc.author_name || doc.author) && 
                               workKeyMatch && (!firstPublishYear || firstPublishYear >= CONFIG.MIN_PUBLISH_YEAR);
                    })
                    .map(doc => {
                        const workKeyMatch = doc.key.match(/\/works\/(OL\d+W)/);
                        const firstPublishYear = doc.first_publish_year && typeof doc.first_publish_year === 'number' ? doc.first_publish_year : null;
                        
                        // Build basic book object
                        const bookObj = {
                            title: doc.title || 'Unknown Title',
                            author: doc.author_name ? doc.author_name.join(', ') : (doc.author || 'Unknown Author'),
                            description: doc.first_sentence?.[0] || '',
                            imageUrl: doc.cover_i ? `${CONFIG.OPEN_LIBRARY_COVER_URL}${doc.cover_i}-M.jpg` : null,
                            goodreadsUrl: `https://openlibrary.org${doc.key}`,
                            rating: doc.ratings_average && typeof doc.ratings_average === 'number' ? doc.ratings_average : null,
                            subjects: doc.subject || [],
                            workKey: workKeyMatch[1],
                            source,
                            first_publish_year: firstPublishYear,
                            hasCover: !!doc.cover_i
                        };

                        // If no cover found in initial search, we'll search for one later when needed
                        if (!bookObj.imageUrl) {
                            bookObj.imageUrl = 'https://placehold.co/400x600/CCCCCC/666666?text=Searching+Cover...';
                            bookObj.needsCoverSearch = true;
                        }

                        return bookObj;
                    });
            }

            isDuplicate(workKey, collection) {
                return appState.data[collection]?.some(book => book.workKey === workKey) || false;
            }

            isExistingBook(workKey) {
                const collections = ['recommendedBooks', 'bookShelfBooks', 'flaggedBooks', 'bethDeletedBooks', 'adminPendingRecommendations', 'adminApprovedBooks'];
                return collections.some(collection => this.isDuplicate(workKey, collection));
            }

            async sendAlert(type, data = '') {
                const timestamp = new Date().toLocaleString();
                let message = '';

                switch (type) {
                    case 'picked_book':
                        const book = appState.data.recommendedBooks.find(b => b.workKey === data);
                        message = `📚 Beth picked: "${book?.title || 'Unknown Book'}" by ${book?.author || 'Unknown Author'}`;
                        break;
                    case 'request_more_recs':
                        message = '🔄 Beth is ready for more book recommendations!';
                        break;
                    case 'passed_book':
                        const passedBook = appState.data.recommendedBooks.find(b => b.workKey === data);
                        message = `❌ Beth passed on: "${passedBook?.title || 'Unknown Book'}" by ${passedBook?.author || 'Unknown Author'}`;
                        break;
                    case 'recommendations_generation_started':
                        message = '⚙️ Admin initiated new recommendation generation.';
                        break;
                    case 'beth_login':
                        message = '👋 Beth logged into her Book Club!';
                        break;
                    case 'book_moved_to_deleted':
                        message = `🗑️ Beth moved "${data.title}" by ${data.author} to deleted books`;
                        break;
                    case 'book_saved_for_later':
                        message = `💾 Beth saved "${data.title}" by ${data.author} for later reading`;
                        break;
                    case 'book_restored_from_deleted':
                        message = `♻️ Beth restored "${data.title}" by ${data.author} from deleted books`;
                        break;
                    case 'book_rating_updated':
                        message = `⭐ Beth rated "${data.title}" as "${data.rating}"`;
                        break;
                }

                const alert = { message, timestamp };
                await storage.addAlert(alert);
            }
        }

        const bookManager = new BookManager();

        // === FIREBASE INTEGRATION ===
        class FirebaseManager {
            async initialize() {
                const firebaseConfig = {
                    apiKey: "AIzaSyAFy0zdwfRbLuOHLvrjRpCo1WVAM_6JES4",
                    authDomain: "beths-book-club.firebaseapp.com",
                    projectId: "beths-book-club",
                    storageBucket: "beths-book-club.firebasestorage.app",
                    messagingSenderId: "383122582606",
                    appId: "1:383122582606:web:b187ccfa0bcfeaba7a671f",
                    measurementId: "G-X584KXZ8TX"
                };

                try {
                    appState.firebaseApp = initializeApp(firebaseConfig);
                    appState.db = getFirestore(appState.firebaseApp);
                    appState.auth = getAuth(appState.firebaseApp);
                    appState.analytics = getAnalytics(appState.firebaseApp);
                    console.log("Firebase initialized successfully");
                    return true;
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    appState.firestoreAvailable = false;
                    storage.notifyOfflineMode();
                    storage.loadFromLocalStorage();
                    return false;
                }
            }

            async migrateData() {
                if (!appState.firestoreAvailable) return;
                
                const migrations = [
                    { key: STORAGE_KEYS.RECOMMENDED_BOOKS, flag: MIGRATION_FLAGS.RECOMMENDED_BOOKS, collection: 'recommended_books' },
                    { key: STORAGE_KEYS.BOOK_SHELF_BOOKS, flag: MIGRATION_FLAGS.BOOKSHELF_BOOKS, collection: 'bookshelf_books' },
                    { key: STORAGE_KEYS.FLAGGED_BOOKS, flag: MIGRATION_FLAGS.FLAGGED_BOOKS, collection: 'flagged_books', userId: appState.adminUserId },
                    { key: STORAGE_KEYS.BETH_DELETED_BOOKS, flag: MIGRATION_FLAGS.BETH_DELETED_BOOKS, collection: 'beth_deleted_books' },
                    { key: STORAGE_KEYS.ADMIN_ALERTS, flag: MIGRATION_FLAGS.ADMIN_ALERTS, collection: 'admin_alerts', userId: appState.adminUserId },
                    { key: STORAGE_KEYS.ADMIN_PENDING_RECS, flag: MIGRATION_FLAGS.ADMIN_PENDING_RECS, collection: 'admin_pending_recs', userId: appState.adminUserId },
                    { key: STORAGE_KEYS.ADMIN_APPROVED_BOOKS, flag: MIGRATION_FLAGS.ADMIN_APPROVED_BOOKS, collection: 'admin_approved_books', userId: appState.adminUserId }
                ];

                for (const migration of migrations) {
                    if (localStorage.getItem(migration.flag) === 'true') continue;

                    const data = localStorage.getItem(migration.key);
                    if (data) {
                        try {
                            const items = JSON.parse(data);
                            if (Array.isArray(items) && items.length > 0) {
                                console.log(`Migrating ${items.length} items from ${migration.key}`);
                                for (const item of items) {
                                    await storage.saveToFirestore(item, migration.collection, migration.userId);
                                }
                                localStorage.setItem(migration.flag, 'true');
                                localStorage.removeItem(migration.key);
                            }
                        } catch (error) {
                            console.error(`Migration failed for ${migration.key}:`, error);
                        }
                    }
                }

                // Special case for negative feedback
                const negativeFeedback = localStorage.getItem(STORAGE_KEYS.BETH_NEGATIVE_FEEDBACK);
                if (negativeFeedback && localStorage.getItem(MIGRATION_FLAGS.BETH_NEGATIVE_FEEDBACK) !== 'true') {
                    try {
                        const terms = JSON.parse(negativeFeedback);
                        if (Array.isArray(terms)) {
                            for (const term of terms) {
                                await this.addNegativeFeedback(term);
                            }
                            localStorage.setItem(MIGRATION_FLAGS.BETH_NEGATIVE_FEEDBACK, 'true');
                            localStorage.removeItem(STORAGE_KEYS.BETH_NEGATIVE_FEEDBACK);
                        }
                    } catch (error) {
                        console.error("Negative feedback migration failed:", error);
                    }
                }
            }

            setupListeners() {
                if (!appState.db) return;

                const collections = [
                    { name: 'recommended_books', target: 'recommendedBooks' },
                    { name: 'bookshelf_books', target: 'bookShelfBooks' },
                    { name: 'beth_deleted_books', target: 'bethDeletedBooks' }
                ];

                const adminCollections = [
                    { name: 'flagged_books', target: 'flaggedBooks' },
                    { name: 'admin_alerts', target: 'adminAlerts' },
                    { name: 'admin_pending_recs', target: 'adminPendingRecommendations' },
                    { name: 'admin_approved_books', target: 'adminApprovedBooks' }
                ];

                let setupCount = 0;
                const totalListeners = collections.length + (appState.adminUserId ? adminCollections.length : 0);

                const checkReady = () => {
                    setupCount++;
                    if (setupCount >= totalListeners) {
                        appState.listenersReady = true;
                        console.log("All Firestore listeners ready");
                    }
                };

                // Public collections
                collections.forEach(({ name, target }) => {
                    onSnapshot(collection(appState.db, storage.getCollectionPath(name)), (snapshot) => {
                        appState.data[target] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        console.log(`Listener: ${name} updated (${appState.data[target].length} items)`);
                        if (appState.uiReadyForDisplay) {
                            ui.refreshAllDisplays();
                        }
                        checkReady();
                    });
                });

                // Admin collections
                if (appState.adminUserId) {
                    adminCollections.forEach(({ name, target }) => {
                        onSnapshot(collection(appState.db, storage.getCollectionPath(name, appState.adminUserId)), (snapshot) => {
                            appState.data[target] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            if (name === 'admin_pending_recs') {
                                appState.data[target].sort((a, b) => b.score - a.score);
                            }
                            console.log(`Listener: ${name} updated (${appState.data[target].length} items)`);
                            if (appState.uiReadyForDisplay) {
                                ui.refreshAllDisplays();
                            }
                            checkReady();
                        });
                    });
                }
            }

            async addNegativeFeedback(term) {
                if (!appState.db || !appState.adminUserId) return;
                
                try {
                    const collectionRef = collection(appState.db, storage.getCollectionPath('negative_feedback', appState.adminUserId));
                    await setDoc(doc(collectionRef, term), { term });
                } catch (error) {
                    console.error("Failed to add negative feedback:", error);
                }
            }

            async getNegativeFeedback() {
                if (!appState.db || !appState.adminUserId) return [];
                
                try {
                    const snapshot = await getDocs(collection(appState.db, storage.getCollectionPath('negative_feedback', appState.adminUserId)));
                    return snapshot.docs.map(doc => doc.data().term);
                } catch (error) {
                    console.error("Failed to get negative feedback:", error);
                    return [];
                }
            }

            async seedInitialBookshelf() {
                if (localStorage.getItem(MIGRATION_FLAGS.INITIAL_BOOKSHELF) === 'true') return;

                const initialBooks = [
                    { url: 'https://openlibrary.org/works/OL24311121W/Rock_Paper_Scissors', userRating: 'love' },
                    { url: 'https://openlibrary.org/works/OL19096402W/The_Silent_Patient', userRating: 'love' },
                    { url: 'https://openlibrary.org/works/OL19749472W/Then_she_was_gone', userRating: 'love' }
                ];

                for (const bookInfo of initialBooks) {
                    const workKeyMatch = bookInfo.url.match(/\/works\/(OL\d+W)/);
                    if (!workKeyMatch) continue;

                    const workKey = workKeyMatch[1];
                    const isAlreadyOnShelf = appState.data.bookShelfBooks.some(book => book.workKey === workKey);

                    if (!isAlreadyOnShelf) {
                        try {
                            const bookDetails = await api.fetchBookDetails(workKey); // Keep default requireCover = true for seeded books
                            if (bookDetails) {
                                const bookToSave = {
                                    title: bookDetails.title || 'Unknown Title',
                                    author: bookDetails.author || 'Unknown Author',
                                    description: bookDetails.description || '',
                                    imageUrl: bookDetails.imageUrl || '',
                                    goodreadsUrl: bookDetails.goodreadsUrl || '',
                                    rating: bookDetails.rating && typeof bookDetails.rating === 'number' ? bookDetails.rating : null,
                                    subjects: bookDetails.subjects || [],
                                    userRating: bookInfo.userRating,
                                    source: 'Initial Seeding',
                                    workKey: bookDetails.workKey,
                                    first_publish_year: bookDetails.first_publish_year && typeof bookDetails.first_publish_year === 'number' ? bookDetails.first_publish_year : null
                                };
                                await storage.saveToFirestore(bookToSave, 'bookshelf_books');
                                console.log(`Seeded: ${bookToSave.title}`);
                            }
                        } catch (error) {
                            console.warn(`Failed to seed book ${workKey}:`, error);
                        }
                    }
                }

                localStorage.setItem(MIGRATION_FLAGS.INITIAL_BOOKSHELF, 'true');
            }
        }

        const firebase = new FirebaseManager();

        // === EVENT HANDLERS ===
        class EventManager {
            constructor() {
                this.setupEventDelegation();
                this.setupStaticEvents();
            }

            getSavedBooksHandlers() {
                return {
                    'pick-and-move-btn': (e) => this.handlePickAndMoveToBookshelf(e.target.dataset.workkey)
                };
            }

            setupEventDelegation() {
                const containers = [
                    { id: 'book-list', handlers: this.getRecommendedBookHandlers() },
                    { id: 'bookshelf-list', handlers: this.getBookshelfHandlers() },
                    { id: 'beth-deleted-books-list', handlers: this.getDeletedBookHandlers() },
                    { id: 'flagged-books-list', handlers: this.getFlaggedBookHandlers() },
                    { id: 'search-results', handlers: this.getSearchResultHandlers() },
                    { id: 'admin-alerts-list', handlers: this.getAlertHandlers() },
                    { id: 'admin-pending-recs-list', handlers: this.getPendingHandlers() },
                    { id: 'admin-approved-books-list', handlers: this.getApprovedHandlers() },
                    { id: 'saved-books-list', handlers: this.getSavedBooksHandlers() }
                ];

                containers.forEach(({ id, handlers }) => {
                    const container = utils.safeGetElement(id);
                    if (container) {
                        container.addEventListener('click', (event) => {
                            const target = event.target;
                            for (const [className, handler] of Object.entries(handlers)) {
                                if (target.classList.contains(className)) {
                                    console.log(`Event handler triggered: ${className} on container ${id}`);
                                    handler(event);
                                    break;
                                }
                            }
                        });
                        console.log(`Event delegation setup for ${id} with handlers:`, Object.keys(handlers));
                    } else {
                        console.warn(`Container not found: ${id}`);
                    }
                });
            }

            getRecommendedBookHandlers() {
                return {
                    'pick-book-btn': (e) => this.handlePickBook(e.target.dataset.workkey),
                    'get-insight-btn': (e) => this.handleGetInsight(e),
                    'pass-book-btn': (e) => this.handlePassBook(e.target.dataset.workkey),
                    'save-for-later-btn': (e) => this.handleSaveForLater(e.target.dataset.workkey),
                    'remove-admin-button': (e) => this.handleRemoveFromRecommended(e.target.dataset.workkey),
                    'move-to-approved-btn': (e) => this.handleMoveToApproved(e.target.dataset.workkey),
                    'red-flag-btn': (e) => this.handleRedFlag(e.target.dataset.workkey, e.target.dataset.author)
                };
            }

            getBookshelfHandlers() {
                return {
                    'update-rating-btn': (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const workKey = e.target.closest('.review-buttons').dataset.bookWorkkey;
                        const rating = e.target.dataset.rating;
                        this.handleUpdateRating(workKey, rating);
                    },
                    'remove-from-bookshelf-btn': (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.handleRemoveFromBookshelf(e.target.dataset.workkey);
                    }
                };
            }

            getDeletedBookHandlers() {
                return {
                    'restore-beth-deleted-btn': (e) => this.handleRestoreFromDeleted(e.target.dataset.workkey)
                };
            }

            getFlaggedBookHandlers() {
                return {
                    'restore-flagged-btn': (e) => this.handleRestoreFromFlagged(e.target.dataset.workkey)
                };
            }

            getSearchResultHandlers() {
                return {
                    'add-to-curated-list-btn': (e) => {
                        console.log('Add to curated list button clicked', e.target);
                        this.handleAddToCuratedList(e);
                    }
                };
            }

            getAlertHandlers() {
                return {
                    'dismiss-admin-alert-btn': (e) => this.handleDismissAlert(e.target.dataset.id)
                };
            }

            getPendingHandlers() {
                return {
                    'approve-for-beth-btn': (e) => this.handleApproveForBeth(e),
                    'skip-pending-btn': (e) => this.handleSkipPending(e.target.dataset.workkey),
                    'red-flag-pending-btn': (e) => this.handleRedFlagPending(e.target.dataset.workkey, e.target.dataset.author)
                };
            }

            getApprovedHandlers() {
                return {
                    'move-to-beths-recs-btn': (e) => this.handleMoveToRecommendations(e),
                    'remove-from-approved-btn': (e) => this.handleRemoveFromApproved(e.target.dataset.workkey)
                };
            }

            setupStaticEvents() {
                // Navigation
                const navButtons = [
                    { id: 'nav-recommendations', view: 'recommendations-view' },
                    { id: 'nav-bookshelf', view: 'bookshelf-view' },
                    { id: 'nav-beth-deleted-books', view: 'beth-deleted-books-view' },
                    { id: 'nav-flagged-books', view: 'flagged-books-view' },
                    { id: 'nav-admin-approved-books', view: 'admin-approved-books-view' }
                ];

                navButtons.forEach(({ id, view }) => {
                    const button = utils.safeGetElement(id);
                    if (button) {
                        button.addEventListener('click', () => ui.showView(view));
                    }
                });

                // View Saved Books Button (centralized)
                const viewSavedBooksButton = utils.safeGetElement('view-saved-books-button');
                if (viewSavedBooksButton) {
                    viewSavedBooksButton.addEventListener('click', () => ui.showView('saved-books-view'));
                }

                // Admin controls
                this.setupAdminControls();

                // Login/logout
                this.setupAuthControls();

                // Input enter key handlers
                this.setupInputHandlers();

                // Message box close
                const closeButton = utils.safeGetElement('message-box-close');
                if (closeButton) {
                    closeButton.addEventListener('click', () => ui.hideMessage());
                }
            }

            setupAdminControls() {
                const adminControls = [
                    { id: 'search-button', handler: () => this.handleSearch() },
                    { id: 'recommend-button', handler: () => bookManager.generateRecommendations() },
                    { id: 'manual-add-button', handler: () => this.handleManualAdd() },
                    { id: 'evaluate-book-button', handler: () => this.handleEvaluateBook() },
                    { id: 'request-more-recs-button', handler: () => this.handleRequestMoreRecs() }
                ];

                adminControls.forEach(({ id, handler }) => {
                    const element = utils.safeGetElement(id);
                    if (element) {
                        element.addEventListener('click', handler);
                    }
                });
            }

            setupAuthControls() {
                const loginButton = utils.safeGetElement('login-button');
                const logoutButton = utils.safeGetElement('logout-button');
                const forgotPinButton = utils.safeGetElement('forgot-pin-button');

                if (loginButton) {
                    loginButton.addEventListener('click', () => this.handleLogin());
                }

                if (logoutButton) {
                    logoutButton.addEventListener('click', () => this.handleLogout());
                }

                if (forgotPinButton) {
                    forgotPinButton.addEventListener('click', () => this.handleForgotPin());
                }

                const pinInput = utils.safeGetElement('pin-input');
                if (pinInput) {
                    pinInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') loginButton?.click();
                    });
                }
            }

            setupInputHandlers() {
                const inputs = [
                    { id: 'search-input', buttonId: 'search-button' },
                    { id: 'manual-add-url-input', buttonId: 'manual-add-button' },
                    { id: 'evaluate-book-url-input', buttonId: 'evaluate-book-button' }
                ];

                inputs.forEach(({ id, buttonId }) => {
                    const input = utils.safeGetElement(id);
                    if (input) {
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                const button = utils.safeGetElement(buttonId);
                                if (button) button.click();
                            }
                        });
                    }
                });
            }

            // Event handler implementations
            async handleLogin() {
                const pinInput = utils.safeGetElement('pin-input');
                const loginMessage = utils.safeGetElement('login-message');
                const enteredPin = pinInput?.value || '';

                if (enteredPin === CONFIG.BETH_PIN) {
                    if (loginMessage) loginMessage.textContent = '';
                    await this.initializeApp(false);
                    // Send alert that Beth logged in
                    await bookManager.sendAlert('beth_login');
                } else if (enteredPin === CONFIG.ADMIN_PIN) {
                    if (loginMessage) loginMessage.textContent = '';
                    await this.initializeApp(true);
                } else {
                    if (loginMessage) {
                        loginMessage.textContent = 'Incorrect PIN. Please try again.';
                        loginMessage.classList.remove('hidden');
                    }
                }
            }

            handleLogout() {
                appState.reset();
                
                const mainContent = utils.safeGetElement('main-content');
                const loginScreen = utils.safeGetElement('login-screen');
                const pinInput = utils.safeGetElement('pin-input');

                if (mainContent) mainContent.classList.add('hidden');
                if (loginScreen) loginScreen.classList.remove('hidden');
                if (pinInput) pinInput.value = '';

                ui.setAdminUIVisibility(false);
                console.log("Logged out successfully");
            }

            handleForgotPin() {
                ui.showMessage(
                    'If you\'ve forgotten your PIN, please contact the administrator.',
                    false,
                    true
                );
            }

            async initializeApp(isAdminLogin) {
                try {
                    appState.adminUserId = CONFIG.BETH_FIREBASE_USER_ID;
                    
                    const firebaseReady = await firebase.initialize();
                    if (firebaseReady) {
                        await firebase.migrateData();
                        firebase.setupListeners();
                        
                        // Wait for listeners
                        await this.waitForListeners();
                        await firebase.seedInitialBookshelf();
                    }

                    // Hide login screen and show main content directly
                    const loginScreen = utils.safeGetElement('login-screen');
                    const mainContent = utils.safeGetElement('main-content');
                    
                    if (loginScreen) loginScreen.classList.add('hidden');
                    if (mainContent) mainContent.classList.remove('hidden');

                    // Set UI ready and refresh displays
                    appState.uiReadyForDisplay = true;
                    ui.refreshAllDisplays();
                    ui.showView('recommendations-view');

                    ui.setAdminUIVisibility(isAdminLogin);

                    const requestMoreContainer = utils.safeGetElement('request-more-recs-container');
                    if (requestMoreContainer) requestMoreContainer.classList.remove('hidden');

                    console.log(`App initialized for ${isAdminLogin ? 'admin' : 'Beth'}`);
                } catch (error) {
                    console.error('App initialization failed:', error);
                    ui.showMessage('Failed to initialize app. Please try again.', false, false);
                }
            }

            async waitForListeners() {
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    const check = () => {
                        if (appState.listenersReady || (Date.now() - startTime) > 5000) {
                            resolve(appState.listenersReady);
                        } else {
                            setTimeout(check, 100);
                        }
                    };
                    check();
                });
            }

            async handlePickBook(workKey) {
                const book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                await bookManager.sendAlert('picked_book', workKey);
                ui.showMessage(`You've picked "${book.title}"! The admin has been notified.`, false, false);

                book.userRating = 'picked';
                await storage.saveToFirestore(book, 'bookshelf_books');
                await storage.deleteFromFirestore(workKey, 'recommended_books');
            }

            async handleGetInsight(event) {
                ui.showMessage('Generating personalized insight... This might take a moment.', true, false);

                const button = event.target;
                if (!button.classList.contains('get-insight-btn') || !button.dataset.bookJson) {
                    ui.showMessage('Error: Invalid book data. Please try refreshing the page.', false, false);
                    return;
                }

                try {
                    const book = JSON.parse(button.dataset.bookJson);
                    const insight = await bookManager.getPersonalizedInsight(book);
                    ui.showMessage(insight, false, true);
                } catch (error) {
                    console.error('Failed to get insight:', error);
                    ui.showMessage('Failed to get personalized insight. Please try again.', false, false);
                }
            }

            async handlePassBook(workKey) {
                const book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                await bookManager.sendAlert('passed_book', workKey);
                ui.showMessage(`You've passed on "${book.title}". You won't see this recommendation again.`, false, false);

                book.userRating = 'passed';
                book.flaggedReason = 'Passed by user';
                await storage.deleteFromFirestore(workKey, 'recommended_books');
                await storage.saveToFirestore(book, 'flagged_books', appState.adminUserId);
            }

            async handleRemoveFromRecommended(workKey) {
                const book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                await storage.deleteFromFirestore(workKey, 'recommended_books');
                ui.showMessage(`"${book.title}" has been removed from Recommended Reads.`, false, false);
            }

            async handleRedFlag(workKey, author) {
                const book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                this.showRedFlagDialog(book, 'recommended_books');
            }

            async handleUpdateRating(workKey, rating) {
                let book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                let sourceCollection = 'recommended_books';

                if (!book) {
                    book = appState.data.bookShelfBooks.find(b => b.workKey === workKey);
                    sourceCollection = 'bookshelf_books';
                }

                if (!book) return;

                // Send alert that Beth updated a book rating
                await bookManager.sendAlert('book_rating_updated', {
                    title: book.title,
                    author: book.author,
                    rating: rating
                });

                book.userRating = rating;

                if (['like', 'love', 'mid', 'picked'].includes(rating)) {
                    await storage.saveToFirestore(book, 'bookshelf_books');
                    if (sourceCollection === 'recommended_books') {
                        await storage.deleteFromFirestore(workKey, 'recommended_books');
                    }
                } else {
                    await storage.saveToFirestore(book, sourceCollection);
                }

                ui.showMessage(`"${book.title}" rated as "${rating}"!`, false, false);
            }

            async handleSaveForLater(workKey) {
                const book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                ui.showMessage(`Saving "${book.title}" for later...`, false, false);

                // Send alert that Beth saved a book for later
                await bookManager.sendAlert('book_saved_for_later', {
                    title: book.title,
                    author: book.author
                });

                // Add savedByUser flag and move to admin approved books
                book.savedByUser = true;
                book.userRating = null; // Reset user rating
                
                await storage.saveToFirestore(book, 'admin_approved_books', appState.adminUserId);
                await storage.deleteFromFirestore(workKey, 'recommended_books');
                
                ui.showMessage(`"${book.title}" has been saved for later! You can view it in your bookshelf.`, false, false);
            }

            async handleMoveToApproved(workKey) {
                const book = appState.data.recommendedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                // Create a clean copy for admin approved books
                const approvedBook = {
                    title: book.title || 'Unknown Title',
                    author: book.author || 'Unknown Author',
                    description: book.description || '',
                    imageUrl: book.imageUrl || '',
                    goodreadsUrl: book.goodreadsUrl || '',
                    rating: book.rating && typeof book.rating === 'number' ? book.rating : null,
                    subjects: book.subjects || [],
                    userRating: book.userRating,
                    workKey: book.workKey,
                    first_publish_year: book.first_publish_year && typeof book.first_publish_year === 'number' ? book.first_publish_year : null,
                    source: book.source || 'Moved by Admin',
                    savedByUser: false, // Mark as admin approved, not user saved
                    score: book.score || null,
                    pros: book.pros || [],
                    cons: book.cons || [],
                    summary: book.summary || ''
                };

                await storage.saveToFirestore(approvedBook, 'admin_approved_books', appState.adminUserId);
                await storage.deleteFromFirestore(workKey, 'recommended_books');
                ui.showMessage(`"${book.title}" has been moved to Admin Approved Books.`, false, false);
            }

            async handleRemoveFromBookshelf(workKey) {
                const book = appState.data.bookShelfBooks.find(b => b.workKey === workKey);
                if (!book) return;

                // Send alert that Beth moved a book to deleted
                await bookManager.sendAlert('book_moved_to_deleted', {
                    title: book.title,
                    author: book.author
                });

                await storage.deleteFromFirestore(workKey, 'bookshelf_books');
                await storage.saveToFirestore(book, 'beth_deleted_books');
                ui.showMessage(`"${book.title}" has been removed from your bookshelf and moved to deleted books.`, false, false);
            }

            async handleRestoreFromDeleted(workKey) {
                const book = appState.data.bethDeletedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                // Send alert that Beth restored a book from deleted
                await bookManager.sendAlert('book_restored_from_deleted', {
                    title: book.title,
                    author: book.author
                });

                await storage.deleteFromFirestore(workKey, 'beth_deleted_books');
                book.userRating = 'picked';
                await storage.saveToFirestore(book, 'bookshelf_books');
                ui.showMessage(`"${book.title}" has been restored to your Bookshelf!`, false, false);
            }

            async handleRestoreFromFlagged(workKey) {
                const book = appState.data.flaggedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                await storage.deleteFromFirestore(workKey, 'flagged_books', appState.adminUserId);
                book.userRating = null;
                book.flaggedReason = null;
                await storage.saveToFirestore(book, 'recommended_books');
                ui.showMessage(`"${book.title}" has been restored to Recommended Reads!`, false, false);
            }

            async handleAddToCuratedList(event) {
                const button = event.currentTarget;
                if (!button.dataset.bookJson) return;

                try {
                    const book = JSON.parse(button.dataset.bookJson);
                    const newBook = {
                        title: book.title || 'Unknown Title',
                        author: book.author || 'Unknown Author',
                        description: book.description || '',
                        imageUrl: book.imageUrl || '',
                        goodreadsUrl: book.goodreadsUrl || '',
                        rating: book.rating && typeof book.rating === 'number' ? book.rating : null,
                        subjects: book.subjects || [],
                        userRating: null,
                        workKey: book.workKey,
                        first_publish_year: book.first_publish_year && typeof book.first_publish_year === 'number' ? book.first_publish_year : null
                    };

                    const isDuplicate = appState.data.recommendedBooks.some(b => b.workKey === newBook.workKey);
                    if (!isDuplicate) {
                        await storage.saveToFirestore(newBook, 'recommended_books');
                        ui.showMessage(`"${newBook.title}" has been added to Beth's Book Club!`, false, false);
                    } else {
                        ui.showMessage(`"${newBook.title}" is already in Beth's Book Club!`, false, false);
                    }
                } catch (error) {
                    console.error('Failed to add book:', error);
                    ui.showMessage('Failed to add book. Please try again.', false, false);
                }
            }

            async handleDismissAlert(id) {
                await storage.deleteAlert(id);
            }

            async handleApproveForBeth(event) {
                const button = event.target;
                if (!button.classList.contains('approve-for-beth-btn') || !button.dataset.bookJson) return;

                try {
                    const book = JSON.parse(button.dataset.bookJson);
                    const isDuplicate = appState.data.adminApprovedBooks.some(b => b.workKey === book.workKey);

                    if (!isDuplicate) {
                        await storage.saveToFirestore(book, 'admin_approved_books', appState.adminUserId);
                        ui.showMessage(`"${book.title}" has been approved!`, false, false);
                    } else {
                        ui.showMessage(`"${book.title}" is already approved!`, false, false);
                    }

                    await storage.deleteFromFirestore(book.workKey, 'admin_pending_recs', appState.adminUserId);
                } catch (error) {
                    console.error('Failed to approve book:', error);
                    ui.showMessage('Failed to approve book. Please try again.', false, false);
                }
            }

            async handleSkipPending(workKey) {
                const book = appState.data.adminPendingRecommendations.find(b => b.workKey === workKey);
                if (!book) return;

                await storage.deleteFromFirestore(workKey, 'admin_pending_recs', appState.adminUserId);
                ui.showMessage(`"${book.title}" has been skipped.`, false, false);
            }

            async handleRedFlagPending(workKey, author) {
                const book = appState.data.adminPendingRecommendations.find(b => b.workKey === workKey);
                if (!book) return;

                this.showRedFlagDialog(book, 'admin_pending_recs');
            }

            async handleMoveToRecommendations(event) {
                const button = event.target;
                if (!button.classList.contains('move-to-beths-recs-btn') || !button.dataset.bookJson) return;

                try {
                    const book = JSON.parse(button.dataset.bookJson);
                    const isDuplicate = appState.data.recommendedBooks.some(b => b.workKey === book.workKey);

                    if (!isDuplicate) {
                        book.userRating = null;
                        await storage.saveToFirestore(book, 'recommended_books');
                        ui.showMessage(`"${book.title}" has been moved to Beth's Recommended Reads!`, false, false);
                    } else {
                        ui.showMessage(`"${book.title}" is already in Beth's Recommended Reads!`, false, false);
                    }

                    await storage.deleteFromFirestore(book.workKey, 'admin_approved_books', appState.adminUserId);
                } catch (error) {
                    console.error('Failed to move book:', error);
                    ui.showMessage('Failed to move book. Please try again.', false, false);
                }
            }

            async handleRemoveFromApproved(workKey) {
                const book = appState.data.adminApprovedBooks.find(b => b.workKey === workKey);
                if (!book) return;

                await storage.deleteFromFirestore(workKey, 'admin_approved_books', appState.adminUserId);
                ui.showMessage(`"${book.title}" has been removed from approved books.`, false, false);
            }

            async handlePickAndMoveToBookshelf(workKey) {
                const book = appState.data.adminApprovedBooks.find(b => b.workKey === workKey && b.savedByUser === true);
                if (!book) return;

                // Send alert that Beth picked a saved book
                await bookManager.sendAlert('picked_book', workKey);

                // Remove from admin approved books
                await storage.deleteFromFirestore(workKey, 'admin_approved_books', appState.adminUserId);
                
                // Add to bookshelf with 'picked' status
                book.userRating = 'picked';
                book.savedByUser = undefined; // Remove this flag since it's now on bookshelf
                await storage.saveToFirestore(book, 'bookshelf_books');
                
                ui.showMessage(`"${book.title}" has been picked and moved to your bookshelf!`, false, false);
            }

            async handleSearch() {
                const queryInput = utils.safeGetElement('search-input');
                const query = queryInput?.value?.trim();
                
                if (!query) {
                    ui.showMessage('Please enter a book title or author to search.', false, false);
                    return;
                }

                if (query.startsWith('http://') || query.startsWith('https://')) {
                    ui.showMessage('Please enter only the book title or author, not a full URL.', false, false);
                    return;
                }

                const loader = utils.safeGetElement('search-loader');
                const message = utils.safeGetElement('search-message');
                const searchResults = utils.safeGetElement('search-results');

                if (searchResults) searchResults.innerHTML = '';
                if (message) message.classList.add('hidden');
                if (loader) loader.style.display = 'block';

                try {
                    const data = await api.searchOpenLibrary(query);
                    if (loader) loader.style.display = 'none';

                    const processedResults = [];
                    for (const bookData of data.docs) {
                        if (!bookData.key || !(bookData.author_name || bookData.author) || !bookData.cover_i) continue;

                        const workKeyMatch = bookData.key.match(/\/works\/(OL\d+W)/);
                        if (!workKeyMatch) continue;

                        try {
                            const bookDetails = await api.fetchBookDetails(workKeyMatch[1]);
                            if (bookDetails) {
                                processedResults.push(bookDetails);
                            }
                        } catch (bookError) {
                            console.warn(`Failed to fetch details for ${workKeyMatch[1]}:`, bookError);
                        }
                    }

                    if (processedResults.length > 0) {
                        // Enhance search results with better covers if needed
                        for (const book of processedResults) {
                            if (book.needsCoverSearch) {
                                console.log(`Searching for cover for search result: "${book.title}"`);
                                const betterCover = await api.searchForBookCover(book.title, book.author, {});
                                if (betterCover) {
                                    book.imageUrl = betterCover;
                                    book.hasCover = true;
                                    book.needsCoverSearch = false;
                                    console.log(`Enhanced search result cover for "${book.title}"`);
                                } else {
                                    book.imageUrl = 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover+Available';
                                    book.needsCoverSearch = false;
                                }
                            }
                        }
                        
                        ui.displaySearchResults(processedResults);
                    } else {
                        if (message) {
                            message.textContent = 'No books found. Try a different search term.';
                            message.classList.remove('hidden');
                        }
                    }
                } catch (error) {
                    console.error('Search failed:', error);
                    if (loader) loader.style.display = 'none';
                    if (message) {
                        message.textContent = 'Failed to load search results. Please try again later.';
                        message.classList.remove('hidden');
                    }
                }
            }

            async handleManualAdd() {
                const urlInput = utils.safeGetElement('manual-add-url-input');
                const url = urlInput?.value?.trim();
                
                if (!url) return;

                const loader = utils.safeGetElement('search-loader');
                const message = utils.safeGetElement('search-message');

                if (message) message.classList.add('hidden');
                if (loader) loader.style.display = 'block';

                try {
                    const workKey = await this.extractWorkKey(url);
                    // Allow books without covers for manual admin adds
                    const bookDetails = await api.fetchBookDetails(workKey, false);

                    if (!bookDetails) {
                        throw new Error('Failed to retrieve book details - book may not exist or URL is invalid');
                    }

                    const newBook = {
                        title: bookDetails.title || 'Unknown Title',
                        author: bookDetails.author || 'Unknown Author', 
                        description: bookDetails.description || '',
                        imageUrl: bookDetails.imageUrl || 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover',
                        goodreadsUrl: bookDetails.goodreadsUrl || '',
                        rating: bookDetails.rating && typeof bookDetails.rating === 'number' ? bookDetails.rating : null,
                        subjects: bookDetails.subjects || [],
                        userRating: null,
                        source: 'Manually Added (Admin)',
                        workKey: bookDetails.workKey,
                        first_publish_year: bookDetails.first_publish_year && typeof bookDetails.first_publish_year === 'number' ? bookDetails.first_publish_year : null
                    };

                    const isDuplicate = appState.data.recommendedBooks.some(b => b.workKey === newBook.workKey);
                    if (!isDuplicate) {
                        await storage.saveToFirestore(newBook, 'recommended_books');
                        ui.showMessage(`"${newBook.title}" has been manually added to Beth's Book Club!`, false, false);
                        if (urlInput) urlInput.value = '';
                        ui.showView('recommendations-view');
                    } else {
                        ui.showMessage(`"${newBook.title}" is already in Beth's Book Club!`, false, false);
                    }
                } catch (error) {
                    console.error('Manual add failed:', error);
                    let errorMessage = 'An error occurred while adding the book.';
                    
                    if (error.message.includes('Invalid Open Library URL')) {
                        errorMessage = 'Invalid URL format. Please use a valid Open Library URL (works or books).';
                    } else if (error.message.includes('Failed to retrieve book details')) {
                        errorMessage = 'Could not find this book. Please check the URL and try again.';
                    } else if (error.message.includes('too old')) {
                        errorMessage = 'This book is too old (before 2000). Only newer books are allowed.';
                    }
                    
                    ui.showMessage(errorMessage, false, false);
                } finally {
                    if (loader) loader.style.display = 'none';
                }
            }

            async handleEvaluateBook() {
                const urlInput = utils.safeGetElement('evaluate-book-url-input');
                const url = urlInput?.value?.trim();
                
                if (!url) return;

                const loader = utils.safeGetElement('search-loader');
                const message = utils.safeGetElement('search-message');

                if (message) message.classList.add('hidden');
                if (loader) loader.style.display = 'block';
                ui.showMessage('Evaluating book for Beth... This might take a moment.', true, false);

                try {
                    const workKey = await this.extractWorkKey(url);
                    // Allow books without covers for manual admin evaluation
                    const bookDetails = await api.fetchBookDetails(workKey, false);

                    if (!bookDetails) {
                        throw new Error('Failed to retrieve book details - book may not exist or URL is invalid');
                    }

                    const { title, author } = bookDetails;
                    const lovedBooks = appState.data.bookShelfBooks.filter(b => b.userRating === 'love');
                    const likedBooks = appState.data.bookShelfBooks.filter(b => b.userRating === 'like');
                    const score = bookManager.calculateBookScore(bookDetails, lovedBooks, likedBooks, new Set());
                    const evaluation = await bookManager.getAIEvaluation(bookDetails);

                    const evaluationHtml = `
                        <h3 class="text-xl font-bold mb-2">Evaluation for "${utils.escapeHtml(title)}" by ${utils.escapeHtml(author)}</h3>
                        <p class="text-lg font-semibold mb-4">Internal Score: <span class="text-emerald-600">${score}/100</span></p>
                        <p class="mb-4">${utils.escapeHtml(evaluation.summary)}</p>
                        <div class="mb-4">
                            <h4 class="font-semibold text-green-700">Pros:</h4>
                            <ul class="list-disc list-inside text-left">
                                ${evaluation.pros.map(p => `<li>${utils.escapeHtml(p)}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="mb-4">
                            <h4 class="font-semibold text-red-700">Cons:</h4>
                            <ul class="list-disc list-inside text-left">
                                ${evaluation.cons.map(c => `<li>${utils.escapeHtml(c)}</li>`).join('')}
                            </ul>
                        </div>
                        <button id="add-evaluated-book-button" class="action-button mt-4 px-6 py-3 bg-emerald-600 hover:bg-emerald-700">Add to Recommended Reads</button>
                    `;

                    ui.showMessage(evaluationHtml, false, true);

                    const addButton = document.getElementById('add-evaluated-book-button');
                    if (addButton) {
                        addButton.addEventListener('click', async () => {
                            const newBook = { 
                                title: bookDetails.title || 'Unknown Title',
                                author: bookDetails.author || 'Unknown Author',
                                description: bookDetails.description || '',
                                imageUrl: bookDetails.imageUrl || 'https://placehold.co/400x600/CCCCCC/666666?text=No+Cover',
                                goodreadsUrl: bookDetails.goodreadsUrl || '',
                                rating: bookDetails.rating && typeof bookDetails.rating === 'number' ? bookDetails.rating : null,
                                subjects: bookDetails.subjects || [],
                                userRating: null,
                                source: bookDetails.source || 'Evaluated Book',
                                workKey: bookDetails.workKey,
                                first_publish_year: bookDetails.first_publish_year && typeof bookDetails.first_publish_year === 'number' ? bookDetails.first_publish_year : null
                            };
                            const isDuplicate = appState.data.recommendedBooks.some(b => b.workKey === newBook.workKey);
                            
                            if (!isDuplicate) {
                                await storage.saveToFirestore(newBook, 'recommended_books');
                                ui.showMessage(`"${newBook.title}" has been added to Beth's Book Club!`, false, false);
                            } else {
                                ui.showMessage(`"${newBook.title}" is already in Beth's Book Club!`, false, false);
                            }
                            
                            ui.hideMessage();
                            if (urlInput) urlInput.value = '';
                        }, { once: true });
                    }
                } catch (error) {
                    console.error('Book evaluation failed:', error);
                    let errorMessage = 'Failed to evaluate book.';
                    
                    if (error.message.includes('Invalid Open Library URL')) {
                        errorMessage = 'Invalid URL format. Please use a valid Open Library URL (works or books).';
                    } else if (error.message.includes('Failed to retrieve book details')) {
                        errorMessage = 'Could not find this book. Please check the URL and try again.';
                    } else if (error.message.includes('too old')) {
                        errorMessage = 'This book is too old (before 2000). Only newer books are allowed.';
                    } else if (error.message.includes('AI evaluation failed')) {
                        errorMessage = 'Book found but AI evaluation failed. The book may still be valid.';
                    }
                    
                    ui.showMessage(errorMessage, false, false);
                } finally {
                    if (loader) loader.style.display = 'none';
                }
            }

            async handleRequestMoreRecs() {
                await bookManager.sendAlert('request_more_recs');
                ui.showMessage("Your request for more recommendations has been sent to the admin!", false, false);
            }

            async extractWorkKey(url) {
                const workKeyMatch = url.match(/\/works\/(OL\d+W)/);
                const bookKeyMatch = url.match(/\/books\/(OL\d+M)/);

                if (workKeyMatch) {
                    return workKeyMatch[1];
                } else if (bookKeyMatch) {
                    const bookKey = bookKeyMatch[1];
                    const response = await api.fetchWithRetry(`https://openlibrary.org/books/${bookKey}.json`);
                    const bookData = await response.json();
                    
                    if (!bookData.works?.length) {
                        throw new Error('No work record found for this book');
                    }
                    
                    const workPath = bookData.works[0].key;
                    const extractedWorkKey = workPath.match(/\/works\/(OL\d+W)/);
                    if (!extractedWorkKey) {
                        throw new Error('Invalid work key format');
                    }
                    return extractedWorkKey[1];
                } else {
                    throw new Error('Invalid Open Library URL. Please provide a URL like https://openlibrary.org/works/OL12345W or https://openlibrary.org/books/OL12345M');
                }
            }

            showRedFlagDialog(book, sourceCollection) {
                const messageBox = utils.safeGetElement('message-box');
                const messageText = utils.safeGetElement('message-text');
                const closeButton = utils.safeGetElement('message-box-close');

                if (!messageBox || !messageText || !closeButton) return;

                const feedbackPrompt = `Why are you flagging "${book.title}" by ${book.author}? (e.g., "romance", "magic", "self-help")`;

                messageText.innerHTML = `
                    <p class="mb-4">${feedbackPrompt}</p>
                    <input type="text" id="flag-reason-input" placeholder="Enter reason (e.g., 'romance', 'magic')"
                           class="w-full p-2 border border-gray-300 rounded-md mb-4 text-gray-700">
                    <button id="submit-flag-reason" class="action-button px-4 py-2 bg-red-600 hover:bg-red-700">Submit Feedback</button>
                    <button id="cancel-flag" class="mt-2 px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500">Cancel</button>
                `;
                messageBox.classList.remove('llm-insight');
                closeButton.style.display = 'none';
                messageBox.style.display = 'block';

                const submitButton = document.getElementById('submit-flag-reason');
                const cancelButton = document.getElementById('cancel-flag');

                if (submitButton) {
                    submitButton.addEventListener('click', async () => {
                        const reasonInput = document.getElementById('flag-reason-input');
                        const reason = reasonInput?.value?.trim() || '';
                        
                        if (reason) {
                            await firebase.addNegativeFeedback(reason.toLowerCase());
                            ui.showMessage(`Feedback received: "${reason}". AI will learn from this!`, false, false);
                        } else {
                            ui.showMessage('No feedback provided.', false, false);
                        }
                        
                        messageBox.style.display = 'none';

                        // Move book to flagged
                        await storage.deleteFromFirestore(book.workKey, sourceCollection, 
                            sourceCollection.includes('admin') ? appState.adminUserId : null);
                        book.userRating = 'flagged';
                        book.flaggedReason = reason || 'No reason provided';
                        await storage.saveToFirestore(book, 'flagged_books', appState.adminUserId);
                    }, { once: true });
                }

                if (cancelButton) {
                    cancelButton.addEventListener('click', () => {
                        messageBox.style.display = 'none';
                    }, { once: true });
                }
            }
        }

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Set current year in footer
            const currentYearElement = utils.safeGetElement('current-year');
            if (currentYearElement) {
                currentYearElement.textContent = new Date().getFullYear();
            }

            // Initialize event management
            new EventManager();

            console.log("Beth's Book Club initialized successfully");
        });

        // Make functions globally accessible for debugging
        window.appState = appState;
        window.utils = utils;
        window.ui = ui;
        window.storage = storage;
        window.api = api;
        window.bookManager = bookManager;
        window.firebase = firebase;

        // Make the cover search available globally for debugging
        window.searchBookCover = async (title, author) => {
            console.log(`Manual cover search for "${title}" by ${author}`);
            const result = await api.searchForBookCover(title, author, {});
            if (result) {
                console.log(`Found cover: ${result}`);
                return result;
            } else {
                console.log('No cover found');
                return null;
            }
        };

    </script>
    <style>
        /* Custom styles for the Inter font and overall look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background for matte, earthy feel */
            color: #334155; /* Darker text for contrast */
            line-height: 1.6;
        }
        .book-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            opacity: 0; /* Start hidden for fade-in animation */
            transform: translateY(20px); /* Start slightly below for slide-up effect */
            animation: fadeInSlideUp 0.5s ease-out forwards; /* Apply animation */
        }
        .book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        /* Keyframe animation for fade-in and slide-up */
        @keyframes fadeInSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Ensure images maintain aspect ratio and fit within their containers */
        .book-image {
            width: 100%;
            height: 250px; /* Fixed height for consistency */
            object-fit: cover; /* Cover the area, cropping if necessary */
            border-radius: 0.5rem; /* Rounded corners for images */
        }

        /* Styles for smaller bookshelf cards */
        .bookshelf-card-small {
            width: 160px; /* Fixed smaller width for bookshelf cards */
            flex-shrink: 0; /* Prevent shrinking in flex containers */
            margin: 0.5rem; /* Small margin around cards */
            text-align: center;
        }

        .bookshelf-card-small .book-image {
            height: 180px; /* Smaller height for images in bookshelf */
        }

        .bookshelf-card-small .p-6 {
            padding: 0.75rem; /* Reduced padding for smaller cards */
        }

        .bookshelf-card-small .text-xl {
            font-size: 1rem; /* Smaller title font size */
        }

        .bookshelf-card-small .text-sm {
            font-size: 0.75rem; /* Smaller author/year font size */
        }

        .bookshelf-card-small .book-description {
            display: -webkit-box;
            -webkit-line-clamp: 3; /* Limit description to 3 lines for smaller cards */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.8rem; /* Smaller description font size */
        }

        .bookshelf-card-small .star-rating svg {
            width: 1rem; /* Smaller stars for bookshelf */
            height: 1rem;
        }


        /* Responsive adjustments for description text (main view) */
        .book-description {
            display: -webkit-box;
            -webkit-line-clamp: 4; /* Limit to 4 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        @media (min-width: 768px) {
            .book-description {
                -webkit-line-clamp: 6; /* More lines on larger screens */
            }
        }
        /* Remove underline from links within book cards */
        .book-link {
            text-decoration: none;
            color: inherit; /* Inherit text color from parent */
            display: flex; /* Make the link fill its container */
            flex-direction: column; /* Stack content vertically */
            height: 100%; /* Ensure the link takes full height of the card */
        }
        /* Star rating styles */
        .star-rating {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            justify-content: center; /* Center stars in small cards */
        }
        .star-rating svg {
            width: 1.25rem; /* Size of the star icon */
            height: 1.25rem;
            fill: #facc15; /* Yellow color for filled stars */
            stroke: #facc15; /* Stroke color for consistency */
            margin-right: 0.125rem; /* Small space between stars */
        }
        .star-rating .empty-star {
            fill: #d1d5db; /* Light gray for empty stars */
            stroke: #d1d5db;
        }

        /* Button styling */
        .action-button {
            background-color: #059669; /* Emerald 600 - Green */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            border: none; /* Remove default button border */
            width: fit-content; /* Adjust width to content */
            margin-top: auto; /* Push button to the bottom of the card */
        }
        .action-button:hover {
            background-color: #047857; /* Emerald 700 - Darker Green on hover */
            transform: translateY(-1px);
        }
        .action-button:active {
            transform: translateY(0);
        }

        /* Specific button colors */
        .action-button.recommend-btn {
            background-color: #e11d48; /* Rose 600 - Pink */
        }
        .action-button.recommend-btn:hover {
            background-color: #be123c; /* Rose 700 - Darker Pink on hover */
        }
        .action-button.insight-btn {
            background-color: #d97706; /* Amber 600 - Yellow */
        }
        .action-button.insight-btn:hover {
            background-color: #b45309; /* Amber 700 - Darker Yellow on hover */
        }
        .action-button.pass-btn { /* New style for pass button */
            background-color: #6b7280; /* Gray 500 */
        }
        .action-button.pass-btn:hover {
            background-color: #4b5563; /* Gray 600 */
        }
        .action-button.red-flag-btn { /* New style for red flag button */
            background-color: #dc2626; /* Red 600 */
        }
        .action-button.red-flag-btn:hover {
            background-color: #b91c1c; /* Red 700 */
        }
        .action-button.save-later-btn { /* New style for save for later button */
            background-color: #8b5cf6; /* Violet 500 */
        }
        .action-button.save-later-btn:hover {
            background-color: #7c3aed; /* Violet 600 */
        }
        .nav-button {
            background-color: transparent;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .nav-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .nav-button.active {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .remove-admin-button {
            background-color: #dc2626; /* Red-600 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            width: 100%; /* Full width within its container */
            margin-top: 1rem; /* Space above */
        }

        .remove-admin-button:hover {
            background-color: #b91c1c; /* Red-700 */
        }

        /* Review buttons specific styling */
        .review-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center; /* Center the buttons */
        }
        .review-button {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid #cbd5e1; /* Light gray border */
            background-color: #f8fafc; /* Light background */
            color: #475569; /* Slate 700 */
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        }
        .review-button:hover {
            background-color: #e2e8f0; /* Lighter on hover */
        }
        .review-button.selected-mid {
            background-color: #fca5a5; /* Red-300 */
            border-color: #ef4444; /* Red-500 */
            color: #7f1d1d; /* Red-900 */
        }
        .review-button.selected-like {
            background-color: #a7f3d0; /* Green-200 */
            border-color: #10b981; /* Green-500 */
            color: #064e3b; /* Green-900 */
        }
        .review-button.selected-love {
            background-color: #bfdbfe; /* Blue-200 */
            border-color: #3b82f6; /* Blue-500 */
            color: #1e3a8a; /* Blue-900 */
        }

        /* Styles for review buttons inside small bookshelf cards */
        .bookshelf-card-small .review-buttons {
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 0.25rem; /* Smaller gap */
            margin-top: 0.5rem; /* Reduced margin */
        }
        .bookshelf-card-small .review-button {
            padding: 0.3rem 0.6rem; /* Smaller padding */
            font-size: 0.7rem; /* Smaller font size */
        }


        /* Message box for pick confirmation and LLM insights */
        .message-box {
            position: fixed;
            top: 50% ;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 1.5rem 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            font-size: 1.125rem;
            font-weight: 500;
            color: #1f2937;
            max-width: 90%; /* Ensure it's responsive */
            word-wrap: break-word; /* Prevent overflow for long text */
        }
        .message-box.llm-insight {
            max-width: 600px; /* Wider for LLM insights */
            text-align: left;
            font-size: 1rem;
        }


        /* Loader styling */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #059669; /* Emerald 600 - Green */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Source tag styling */
        .source-tag {
            display: inline-block;
            background-color: #e0f2f7; /* Light blue */
            color: #083344; /* Dark blue text */
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }

        /* Admin Alert specific styling */
        .admin-alert-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .admin-alert-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #fef3c7; /* Light yellow for alerts */
            border-left: 4px solid #f59e0b; /* Amber border */
            border-radius: 0.25rem;
            font-size: 0.9rem;
            color: #78350f; /* Darker amber text */
            word-wrap: break-word; /* Handle long book titles */
        }
        .admin-alert-item:last-child {
            margin-bottom: 0;
        }
        .admin-alert-item .dismiss-button {
            background-color: #f59e0b;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .admin-alert-item .dismiss-button:hover {
            background-color: #d97706;
        }

        /* New styles for admin pending recommendations */
        .admin-pending-recs-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .admin-pending-rec-item {
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #e0f2fe; /* Light blue for pending */
            border-left: 4px solid #3b82f6; /* Blue border */
            border-radius: 0.25rem;
            font-size: 0.9rem;
            color: #1e40af; /* Darker blue text */
        }
        .admin-pending-rec-item .book-info {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .admin-pending-rec-item .approve-button {
            background-color: #3b82f6;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            align-self: flex-end; /* Align button to the right */
        }
        .admin-pending-rec-item .approve-button:hover {
            background-color: #2563eb;
        }

        /* New styles for admin approved books */
        .admin-approved-books-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .admin-approved-book-item {
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #d1fae5; /* Light green for approved */
            border-left: 4px solid #10b981; /* Green border */
            border-radius: 0.25rem;
            font-size: 0.9rem;
            color: #065f46; /* Darker green text */
        }
        .admin-approved-book-item .book-info {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .admin-approved-book-item .move-to-recs-button {
            background-color: #10b981;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            align-self: flex-end;
        }
        .admin-approved-book-item .move-to-recs-button:hover {
            background-color: #059669;
        }
    </style>
</head>
<body class="antialiased">
    <!-- Message box for pick confirmation and other messages -->
    <div id="message-box" class="message-box">
        <p id="message-text"></p>
        <button id="message-box-close" class="mt-4 px-4 py-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700">Close</button>
    </div>

    <!-- Login Screen -->
    <div id="login-screen" class="min-h-screen flex items-center justify-center bg-gray-100">
        <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-sm text-center">
            <h2 class="text-2xl font-bold mb-6 text-gray-800">Beth's Book Club Login</h2>
            <input type="password" id="pin-input" placeholder="Enter 4-digit PIN" maxlength="4"
                   class="w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700 text-center text-xl tracking-widest">
            <button id="login-button" class="action-button w-full mt-6 px-6 py-3 bg-emerald-600 hover:bg-emerald-700">Login</button>
            <p id="login-message" class="text-red-500 mt-4 hidden"></p>
            <button id="forgot-pin-button" class="text-blue-600 hover:underline mt-4 text-sm">Forgot PIN?</button>
        </div>
    </div>

    <!-- Main Content Area (Now always in DOM, its children are hidden) -->
    <div id="main-content" class="min-h-screen flex flex-col hidden">
        <!-- Header Section -->
        <header class="bg-gradient-to-r from-emerald-800 to-gray-900 text-white shadow-lg py-6 px-4 sm:px-6 lg:px-8">
            <div class="max-w-7xl mx-auto flex flex-col sm:flex-row justify-between items-center">
                <h1 class="text-4xl font-extrabold tracking-tight mb-2 sm:mb-0 flex items-center gap-2" id="main-title">
                    Beth's Book Club
                </h1>
                <p class="text-xl opacity-90">Curated reads for you, my love.</p>
                <!-- Logout Button -->
                <button id="logout-button" class="action-button bg-red-500 hover:bg-red-600 px-4 py-2 text-sm mt-4 sm:mt-0">Logout</button>
            </div>
            <nav class="max-w-7xl mx-auto mt-4 flex justify-center space-x-4">
                <button id="nav-recommendations" class="nav-button active">Recommended Reads</button>
                <button id="nav-bookshelf" class="nav-button">My Bookshelf</button>
                <!-- Deleted books tab - visible to both user and admin -->
                <button id="nav-beth-deleted-books" class="nav-button">Deleted Books</button>
                <!-- Admin-only tabs, initially hidden and controlled by PIN login -->
                <button id="nav-flagged-books" class="nav-button hidden">Flagged Books</button>
                <button id="nav-admin-approved-books" class="nav-button hidden">Admin Approved</button>
            </nav>
        </header>

        <!-- Admin Search Section (Initially Hidden and controlled by PIN login) -->
        <section id="admin-search-panel" class="py-8 px-4 sm:px-6 lg:px-8 bg-gray-100 border-b border-gray-200 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">Admin: Find & Add Books</h2>

                <!-- Admin Alerts Container -->
                <div id="admin-alerts-container" class="admin-alert-container hidden">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Admin Alerts</h3>
                    <div id="admin-alerts-list">
                        <!-- Admin alerts will be displayed here -->
                    </div>
                    <p id="no-admin-alerts-message" class="text-center text-gray-600 mt-4 hidden"></p>
                </div>

                <!-- Admin Pending Recommendations Container -->
                <div id="admin-pending-recs-container" class="admin-pending-recs-container hidden">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Admin: Pending Recommendations (All Generated Books)</h3>
                    <div id="admin-pending-recs-list">
                        <!-- Pending recommendations will be displayed here -->
                    </div>
                    <p id="no-admin-pending-recs-message" class="text-center text-gray-600 mt-4 hidden"></p>
                </div>

                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-8">
                    <input type="text" id="search-input" placeholder="Search by title or author..."
                           class="flex-grow p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700">
                    <button id="search-button" class="action-button px-6 py-3">Search Books</button>
                    <button id="recommend-button" class="action-button recommend-btn px-6 py-3">Get Recommendations</button>
                </div>

                <div class="mt-8 flex flex-col sm:flex-row items-center justify-center gap-4">
                   <input type="text" id="manual-add-url-input" placeholder="Paste Open Library URL (works or books: https://openlibrary.org/works/OL12345W or https://openlibrary.org/books/OL12345M)"
       class="flex-grow p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700">
                    <button id="manual-add-button" class="action-button px-6 py-3 bg-blue-600 hover:bg-blue-700">Add Manually</button>
                </div>

                <!-- New: Evaluate Book for Beth -->
                <div class="mt-8 flex flex-col sm:flex-row items-center justify-center gap-4">
                 <input type="text" id="evaluate-book-url-input" placeholder="Evaluate Book for Beth (Open Library URL: works or books)"
       class="flex-grow p-3 border border-gray-300 rounded-md shadow-sm focus:ring-emerald-500 focus:border-emerald-500 text-gray-700">     <button id="evaluate-book-button" class="action-button px-6 py-3 bg-purple-600 hover:bg-purple-700">Evaluate Book</button>
                </div>


                <div id="search-results" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mt-8">
                    <!-- Search results will be displayed here -->
                </div>
                <div id="search-loader" class="loader"></div>
                <p id="search-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Main Content Area for Curated Books -->
        <main id="recommendations-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 id="recommended-reads-heading" class="text-3xl font-bold text-center mb-10 text-gray-800">Recommended Reads (This Month)</h2>
                <div id="book-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                    <!-- Curated book cards will be dynamically inserted here by JavaScript -->
                </div>
                <p id="no-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
                <!-- New button for Beth to request more recommendations (visibility controlled by PIN login) -->
                <div id="request-more-recs-container" class="mt-10 text-center hidden">
                    <button id="request-more-recs-button" class="action-button px-8 py-4 text-lg bg-blue-500 hover:bg-blue-600">Ready for More Recommendations!</button>
                </div>
            </div>
        </main>

        <!-- Beth's Bookshelf Section -->
        <section id="bookshelf-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-6 text-gray-800">Beth's Bookshelf</h2>
                <!-- Centralized View Saved Books Button -->
                <div class="text-center mb-8">
                    <button id="view-saved-books-button" class="action-button save-later-btn px-8 py-3 text-lg">View Saved Books</button>
                </div>
                <!-- Adjusted grid for smaller cards on bookshelf -->
                <div id="bookshelf-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Books from the bookshelf will be dynamically inserted here -->
                </div>
                <p id="no-bookshelf-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Beth's Deleted Books Section (Always visible) -->
        <section id="beth-deleted-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Beth's Deleted Books</h2>
                <div id="beth-deleted-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Beth's deleted books will be dynamically inserted here -->
                </div>
                <p id="no-beth-deleted-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Admin Flagged Books Section (Initially Hidden and controlled by PIN login) -->
        <section id="flagged-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Admin: Flagged Books</h2>
                <div id="flagged-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Flagged books (passed/red-flagged) will be dynamically inserted here -->
                </div>
                <p id="no-flagged-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Admin Approved Books Section (Initially Hidden and controlled by PIN login) -->
        <section id="admin-approved-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Admin: Approved Books</h2>
                <div id="admin-approved-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Admin approved books will be dynamically inserted here -->
                </div>
                <p id="no-admin-approved-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Saved Books Section (User's saved for later books) -->
        <section id="saved-books-view" class="flex-grow py-12 px-4 sm:px-6 lg:px-8 hidden">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-3xl font-bold text-center mb-10 text-gray-800">Books Saved for Later</h2>
                <div id="saved-books-list" class="flex flex-wrap justify-center gap-4">
                    <!-- User's saved books will be dynamically inserted here -->
                </div>
                <p id="no-saved-books-message" class="text-center text-gray-600 mt-4 hidden"></p>
            </div>
        </section>

        <!-- Footer Section -->
        <footer class="bg-gray-800 text-gray-300 py-8 px-4 sm:px-6 lg:px-8 mt-auto">
            <div class="max-w-7xl mx-auto text-center">
                <p>&copy; <span id="current-year"></span> Beth's Book Club. All rights reserved.</p>
                <p class="text-sm mt-2">Designed with ❤️ for you.</p>
            </div>
        </footer>
    </div>
</body>
</html>
